This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  main/
    java/
      circular/
        enterprise/
          apis/
            CCertificate.java
            CEPAccount.java
            Helper.java
  test/
    java/
      circular/
        enterprise/
          apis/
            IntegrationTest.java
.gitignore
LICENSE
pom.xml
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/main/java/circular/enterprise/apis/CCertificate.java">
package circular.enterprise.apis;

import com.fasterxml.jackson.databind.ObjectMapper;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

/**
 * Circular Certificate Class for certificate chaining
 */
public class CCertificate {
    private String data;
    private String previousTxID;
    private String previousBlock;
    private static final ObjectMapper objectMapper = new ObjectMapper();

    public CCertificate() {
        this.data = null;
        this.previousTxID = null;
        this.previousBlock = null;
    }

    /**
     * Insert application data into the certificate
     * @param data Data content
     */
    public void setData(String data) {
        this.data = Helper.stringToHex(data);
    }

    /**
     * Extract application data from the certificate
     * @return Data content
     */
    public String getData() {
        return Helper.hexToString(this.data);
    }

    /**
     * Get the certificate in JSON format
     * @return JSON-encoded certificate
     * @throws Exception if JSON serialization fails
     */
    public String getJsonCertificate() throws Exception {
        Map<String, Object> certificate = new HashMap<>();
        certificate.put("data", getData());
        certificate.put("previousTxID", previousTxID);
        certificate.put("previousBlock", previousBlock);
        certificate.put("version", Helper.LIB_VERSION);
        
        return objectMapper.writeValueAsString(certificate);
    }

    /**
     * Get the size of the certificate in bytes
     * @return Size of the certificate
     */
    public int getCertificateSize() {
        try {
            return getJsonCertificate().getBytes(StandardCharsets.UTF_8).length;
        } catch (Exception e) {
            return 0;
        }
    }

    // Getters and setters for previousTxID and previousBlock
    public String getPreviousTxID() {
        return previousTxID;
    }

    public void setPreviousTxID(String previousTxID) {
        this.previousTxID = previousTxID;
    }

    public String getPreviousBlock() {
        return previousBlock;
    }

    public void setPreviousBlock(String previousBlock) {
        this.previousBlock = previousBlock;
    }
}
</file>

<file path="src/main/java/circular/enterprise/apis/Helper.java">
package circular.enterprise.apis;

import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.nio.charset.StandardCharsets;

/**
 * CIRCULAR Enterprise APIs for Data Certification
 *
 * License : Open Source for private and commercial use
 *
 * CIRCULAR GLOBAL LEDGERS, INC. - USA
 *
 * Version : 1.0.0
 *
 * Creation: 13/3/2025
 * Update  : 13/3/2025
 *
 * Originator: Gianluca De Novi, PhD
 * Contributors: Danny De Novi
 */
public class Helper {
    // Global Constants
    public static final String LIB_VERSION = "1.0.13";
    public static final String NETWORK_URL = "https://circularlabs.io/network/getNAG?network=";
    public static final String DEFAULT_CHAIN = "0x8a20baa40c45dc5055aeb26197c203e576ef389d9acb171bd62da11dc5ad72b2";
    public static final String DEFAULT_NAG = "https://nag.circularlabs.io/NAG.php?cep=";

    /**
     * Function to add a leading zero to numbers less than 10
     * @param num Number to pad
     * @return Padded number
     */
    public static String padNumber(int num) {
        return num < 10 ? "0" + num : String.valueOf(num);
    }

    /**
     * Function to get the current timestamp in the format YYYY:MM:DD-HH:MM:SS
     * @return Formatted timestamp
     */
    public static String getFormattedTimestamp() {
        ZonedDateTime nowUtc = ZonedDateTime.now(ZoneOffset.UTC);
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy:MM:dd-HH:mm:ss");
        return nowUtc.format(formatter);
    }

    /**
     * Removes '0x' from hexadecimal numbers if they have it
     * @param hexStr Hexadecimal string
     * @return Cleaned hexadecimal string
     */
    public static String hexFix(String hexStr) {
        return hexStr != null ? hexStr.replace("0x", "") : "";
    }

    /**
     * Convert a string to its hexadecimal representation without '0x'
     * @param str Input string
     * @return Hexadecimal representation
     */
    public static String stringToHex(String str) {
        if (str == null) return "";
        byte[] bytes = str.getBytes(StandardCharsets.UTF_8);
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    }

    /**
     * Convert a hexadecimal string to a regular string
     * @param hexStr Hexadecimal string
     * @return Regular string
     */
    public static String hexToString(String hexStr) {
        if (hexStr == null || hexStr.length() % 2 != 0) return "";
        
        byte[] bytes = new byte[hexStr.length() / 2];
        for (int i = 0; i < hexStr.length(); i += 2) {
            bytes[i / 2] = (byte) Integer.parseInt(hexStr.substring(i, i + 2), 16);
        }
        return new String(bytes, StandardCharsets.UTF_8);
    }
}
</file>

<file path=".gitignore">
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from https://github.com/github/gitignore/blob/main/VisualStudio.gitignore

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET Core
project.lock.json
project.fragment.lock.json
artifacts/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
# but not Directory.Build.rsp, as it configures directory-level build defaults
!Directory.Build.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.tlog
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio 6 auto-generated project file (contains which files were open etc.)
*.vbp

# Visual Studio 6 workspace and project file (working project files containing files to include in project)
*.dsw
*.dsp

# Visual Studio 6 technical files
*.ncb
*.aps

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# Visual Studio History (VSHistory) files
.vshistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd

# VS Code files for those working on multiple tools
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# Local History for Visual Studio Code
.history/

# Windows Installer files from build outputs
*.cab
*.msi
*.msix
*.msm
*.msp

# JetBrains Rider
*.sln.iml
</file>

<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>io.circular.protocol</groupId>
    <artifactId>circular-enterprise-apis</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <name>Circular Enterprise APIs</name>
    <description>Official Circular Protocol Enterprise APIs for Data Certification - Java Implementation</description>

    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <junit.jupiter.version>5.10.2</junit.jupiter.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.15.2</version>
        </dependency>
        <dependency>
            <groupId>com.squareup.okhttp3</groupId>
            <artifactId>okhttp</artifactId>
            <version>4.11.0</version>
        </dependency>
        <dependency>
            <groupId>org.bouncycastle</groupId>
            <artifactId>bcprov-jdk15on</artifactId>
            <version>1.70</version>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-api</artifactId>
            <version>${junit.jupiter.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>${junit.jupiter.version}</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.2.5</version>
                <configuration>
                    <includes>
                        <include>**/*Test.java</include>
                    </includes>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-source-plugin</artifactId>
                <version>3.3.0</version>
                <executions>
                    <execution>
                        <id>attach-sources</id>
                        <goals>
                            <goal>jar-no-fork</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-javadoc-plugin</artifactId>
                <version>3.6.0</version>
                <executions>
                    <execution>
                        <id>attach-javadocs</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-gpg-plugin</artifactId>
                <version>1.6</version>
                <executions>
                    <execution>
                        <id>sign-artifacts</id>
                        <phase>verify</phase>
                        <goals>
                            <goal>sign</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.sonatype.plugins</groupId>
                <artifactId>nexus-staging-maven-plugin</artifactId>
                <version>1.6.13</version>
                <extensions>true</extensions>
                <configuration>
                    <serverId>ossrh</serverId>
                    <nexusUrl>https://oss.sonatype.org/</nexusUrl>
                    <autoReleaseAfterClose>true</autoReleaseAfterClose>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <distributionManagement>
        <snapshotRepository>
            <id>ossrh</id>
            <url>https://oss.sonatype.org/content/repositories/snapshots</url>
            <releases>
                <enabled>false</enabled>
            </releases>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </snapshotRepository>
        <repository>
            <id>ossrh</id>
            <url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>
            <releases>
                <enabled>true</enabled>
            </releases>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </repository>
    </distributionManagement>

    <licenses>
        <license>
            <name>MIT License</name>
            <url>https://opensource.org/licenses/MIT</url>
            <distribution>repo</distribution>
        </license>
    </licenses>

    <developers>
        <developer>
            <name>Danny De Novi</name>
            <email>ddenovi@circularlabs.io</email>
            <organization>CIRCULAR GLOBAL LEDGERS, INC.</organization>
        </developer>
    </developers>

    <scm>
        <connection>scm:git:git@github.com:circular-protocol/Java-Enterprise-APIs.git</connection>
        <developerConnection>scm:git:git@github.com:circular-protocol/Java-Enterprise-APIs.git</developerConnection>
        <url>https://github.com/circular-protocol/Java-Enterprise-APIs</url>
    </scm>
</project>
</file>

<file path="src/main/java/circular/enterprise/apis/CEPAccount.java">
package circular.enterprise.apis;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import okhttp3.*;
import org.bouncycastle.asn1.x9.X9ECParameters;
import org.bouncycastle.crypto.ec.CustomNamedCurves;
import org.bouncycastle.crypto.params.ECDomainParameters;
import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
import org.bouncycastle.crypto.signers.ECDSASigner;
import org.bouncycastle.crypto.signers.HMacDSAKCalculator;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.math.ec.FixedPointCombMultiplier;

import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.Security;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * Circular Account Class
 */
public class CEPAccount {
    private String address;
    private String publicKey;
    private Map<String, Object> info;
    private final String codeVersion;
    private String lastError;
    private String nagUrl;
    private String networkNode;
    private String blockchain;
    private String latestTxID;
    private long nonce;
    private Object[] data;
    private int intervalSec;
    private static final OkHttpClient client;
    private static final ObjectMapper objectMapper;
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

    static {
        client = new OkHttpClient.Builder()
                .connectTimeout(30, TimeUnit.SECONDS)
                .readTimeout(30, TimeUnit.SECONDS)
                .writeTimeout(30, TimeUnit.SECONDS)
                .build();
        objectMapper = new ObjectMapper();
        Security.addProvider(new BouncyCastleProvider());
    }

    public CEPAccount() {
        this.address = null;
        this.publicKey = null;
        this.info = null;
        this.codeVersion = Helper.LIB_VERSION;
        this.lastError = "";
        this.nagUrl = Helper.DEFAULT_NAG;
        this.networkNode = "";
        this.blockchain = Helper.DEFAULT_CHAIN;
        this.latestTxID = "";
        this.nonce = 0;
        this.data = new Object[0];
        this.intervalSec = 2;
    }

    /**
     * Open an account by retrieving all the account info
     * @param address Account address
     * @return True if successful, False otherwise
     */
    public boolean open(String address) {
        if (address == null || address.isEmpty()) {
            this.lastError = "Invalid address";
            return false;
        }
        this.address = address;
        return true;
    }

    /**
     * Update the account data and Nonce field
     * @return True if successful, False otherwise
     */
    public boolean updateAccount() {
        if (this.address == null) {
            this.lastError = "Account not open";
            return false;
        }

        try {
            Map<String, String> data = new HashMap<>();
            data.put("Blockchain", Helper.hexFix(this.blockchain));
            data.put("Address", Helper.hexFix(this.address));
            data.put("Version", this.codeVersion);

            String jsonBody = objectMapper.writeValueAsString(data);
            RequestBody body = RequestBody.create(jsonBody, JSON);
            Request request = new Request.Builder()
                    .url(this.nagUrl + "Circular_GetWalletNonce_")
                    .post(body)
                    .build();

            try (Response response = client.newCall(request).execute()) {
                if (!response.isSuccessful()) throw new Exception("Network error: " + response.code());
                
                String responseBody = response.body().string();
                Map<String, Object> responseData = objectMapper.readValue(responseBody, Map.class);
                
                if (responseData.get("Result").equals(200) && 
                    responseData.containsKey("Response") && 
                    ((Map)responseData.get("Response")).containsKey("Nonce")) {
                    this.nonce = ((Number)((Map)responseData.get("Response")).get("Nonce")).longValue() + 1;
                    return true;
                } else {
                    this.lastError = "Invalid response format or missing Nonce field";
                    return false;
                }
            }
        } catch (Exception e) {
            this.lastError = "Error: " + e.getMessage();
            return false;
        }
    }

    /**
     * Set the blockchain network
     * @param network Network name (e.g., 'devnet', 'testnet', 'mainnet')
     * @return URL of the network
     * @throws Exception if network URL cannot be fetched
     */
    public String setNetwork(String network) throws Exception {
        String nagUrl = Helper.NETWORK_URL + network;
        System.out.println("Fetching network info from: " + nagUrl);
        Request request = new Request.Builder()
                .url(nagUrl)
                .get()
                .build();

        try (Response response = client.newCall(request).execute()) {
            if (!response.isSuccessful()) throw new Exception("Network error: " + response.code());
            
            String responseBody = response.body().string();
            System.out.println("Network response: " + responseBody);
            Map<String, Object> data = objectMapper.readValue(responseBody, new TypeReference<Map<String, Object>>() {});
            this.nagUrl = data.get("url");
            return (String) data.get("url");
        }
    }

    /**
     * Set the blockchain address
     * @param blockchain Blockchain address
     */
    public void setBlockchain(String blockchain) {
        this.blockchain = blockchain;
    }

    /**
     * Close the account
     */
    public void close() {
        this.address = null;
        this.publicKey = null;
        this.info = null;
        this.lastError = "";
        this.nagUrl = null;
        this.networkNode = null;
        this.blockchain = null;
        this.latestTxID = null;
        this.data = null;
        this.nonce = 0;
        this.intervalSec = 0;
    }

    /**
     * Sign data using the account's private key
     * @param message Message to sign
     * @param privateKeyHex Private key in hex format
     * @return Signature in hex format
     * @throws Exception if signing fails
     */
    private String signData(String message, String privateKeyHex) throws Exception {
        if (this.address == null) {
            throw new Exception("Account is not open");
        }

        // Get curve parameters
        X9ECParameters curve = CustomNamedCurves.getByName("secp256k1");
        ECDomainParameters domain = new ECDomainParameters(curve.getCurve(), curve.getG(), curve.getN(), curve.getH());

        // Create signer with RFC 6979 deterministic k
        ECDSASigner signer = new ECDSASigner(new HMacDSAKCalculator(new org.bouncycastle.crypto.digests.SHA256Digest()));
        
        // Set up private key - ensure it's properly formatted
        String cleanPrivateKey = Helper.hexFix(privateKeyHex);
        if (cleanPrivateKey.length() != 64) {
            throw new Exception("Invalid private key length. Expected 64 characters (32 bytes)");
        }
        BigInteger privateKey = new BigInteger(cleanPrivateKey, 16);
        ECPrivateKeyParameters privateKeyParams = new ECPrivateKeyParameters(privateKey, domain);
        signer.init(true, privateKeyParams);

        // Hash the message - ensure UTF-8 encoding
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] messageHash = digest.digest(message.getBytes("UTF-8"));

        // Ensure the hash is treated as a positive number
        BigInteger messageHashBigInt = new BigInteger(1, messageHash);
        
        // Sign the hash
        BigInteger[] signature = signer.generateSignature(messageHash);
        
        // Normalize S value to be in lower half of curve order
        BigInteger halfN = domain.getN().shiftRight(1);
        if (signature[1].compareTo(halfN) > 0) {
            signature[1] = domain.getN().subtract(signature[1]);
        }
        
        // Convert to DER format
        byte[] derSignature = toDERFormat(signature[0], signature[1]);
        
        // Convert to hex
        return bytesToHex(derSignature);
    }

    /**
     * Get transaction by ID
     * @param txId Transaction ID
     * @param start Start block
     * @param end End block
     * @return Transaction data
     * @throws Exception if request fails
     */
    private Map<String, Object> getTransactionById(String txId, long start, long end) throws Exception {
        Map<String, String> data = new HashMap<>();
        data.put("Blockchain", Helper.hexFix(this.blockchain));
        data.put("ID", Helper.hexFix(txId));
        data.put("Start", String.valueOf(start));
        data.put("End", String.valueOf(end));
        data.put("Version", this.codeVersion);

        String url = this.nagUrl + "Circular_GetTransactionbyID_" + this.networkNode;
        String jsonBody = objectMapper.writeValueAsString(data);
        RequestBody body = RequestBody.create(jsonBody, JSON);
        
        Request request = new Request.Builder()
                .url(url)
                .post(body)
                .build();

        try (Response response = client.newCall(request).execute()) {
            if (!response.isSuccessful()) throw new Exception("Network error: " + response.code());
            return objectMapper.readValue(response.body().string(), Map.class);
        }
    }

        /**
     * Get transaction by ID and BlockNumner
     * @param txId Transaction ID
     * @param start Start block
     * @param end End block
     * @return Transaction data
     * @throws Exception if request fails
     */
    public Map<String, Object> getTransaction(String BlockID, String txId) throws Exception {
        Map<String, String> data = new HashMap<>();
        data.put("Blockchain", Helper.hexFix(this.blockchain));
        data.put("ID", Helper.hexFix(txId));
        data.put("Start", BlockID);
        data.put("End", BlockID);
        data.put("Version", this.codeVersion);

        String url = this.nagUrl + "Circular_GetTransactionbyID_" + this.networkNode;
        String jsonBody = objectMapper.writeValueAsString(data);
        RequestBody body = RequestBody.create(jsonBody, JSON);
        
        Request request = new Request.Builder()
                .url(url)
                .post(body)
                .build();

        try (Response response = client.newCall(request).execute()) {
            if (!response.isSuccessful()) throw new Exception("Network error: " + response.code());
            return objectMapper.readValue(response.body().string(), Map.class);
        }
    }

    /**
     * Get transaction outcome with polling
     * @param txId Transaction ID
     * @param timeoutSec Timeout in seconds
     * @param intervalSec Polling interval in seconds
     * @return Transaction outcome
     * @throws Exception if timeout or other error occurs
     */
    public Map<String, Object> getTransactionOutcome(String txId, int timeoutSec, int intervalSec) throws Exception {
        Instant startTime = Instant.now();
        
        while (true) {
            if (Instant.now().getEpochSecond() - startTime.getEpochSecond() > timeoutSec) {
                throw new Exception("Timeout exceeded");
            }

            Map<String, Object> data = getTransactionById(txId, 0, 10);
            
            if ((Integer)data.get("Result") == 200 && 
                !data.get("Response").equals("Transaction Not Found") &&
                !((Map)data.get("Response")).get("Status").equals("Pending")) {
                return data;
            }
            
            Thread.sleep(intervalSec * 1000L);
        }
    }

    /**
     * Submit a certificate
     * @param pdata Certificate data
     * @param privateKeyHex Private key in hex format
     * @throws Exception if submission fails
     */
    public void submitCertificate(String pdata, String privateKeyHex) throws Exception {
        if (this.address == null) {
            throw new Exception("Account is not open");
        }

        // Create the initial payload object and convert to hex
        Map<String, String> payloadObject = new HashMap<>();
        payloadObject.put("Action", "CP_CERTIFICATE");
        payloadObject.put("Data", Helper.stringToHex(pdata));
        
        String jsonStr = objectMapper.writeValueAsString(payloadObject);
        String payload = Helper.stringToHex(jsonStr);
        
        // Get current timestamp in the correct format
        String timestamp = Helper.getFormattedTimestamp();
        
        // Create the string for hashing (exactly as in PHP)
        String strToHash = Helper.hexFix(this.blockchain) + 
                          Helper.hexFix(this.address) + 
                          Helper.hexFix(this.address) + 
                          payload + 
                          String.valueOf(this.nonce) + 
                          timestamp;
        
        // Generate the ID using SHA-256
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        String id = bytesToHex(digest.digest(strToHash.getBytes("UTF-8")));
        
        // Sign the ID (not the payload)
        String signature = signData(id, privateKeyHex);
        
        // Create the complete transaction data
        Map<String, String> transactionData = new HashMap<>();
        transactionData.put("ID", id);
        transactionData.put("From", Helper.hexFix(this.address));
        transactionData.put("To", Helper.hexFix(this.address));
        transactionData.put("Timestamp", timestamp);
        transactionData.put("Payload", payload);
        transactionData.put("Nonce", String.valueOf(this.nonce));
        transactionData.put("Signature", signature);
        transactionData.put("Blockchain", Helper.hexFix(this.blockchain));
        transactionData.put("Type", "C_TYPE_CERTIFICATE");
        transactionData.put("Version", this.codeVersion);

        // Submit the certificate
        String jsonBody = objectMapper.writeValueAsString(transactionData);
        System.out.println("Submitting transaction: " + jsonBody);
        RequestBody body = RequestBody.create(jsonBody, JSON);
        Request request = new Request.Builder()
                .url(this.nagUrl + "Circular_AddTransaction_" + this.networkNode)
                .post(body)
                .build();

        try (Response response = client.newCall(request).execute()) {
            if (!response.isSuccessful()) throw new Exception("Network error: " + response.code());
            
            String responseBody = response.body().string();
            System.out.println("Response: " + responseBody);
            Map<String, Object> responseData = objectMapper.readValue(responseBody, Map.class);
            
            int resultCode = ((Number) responseData.get("Result")).intValue();
            if (resultCode == 200) {
                // Save our generated transaction ID
                this.latestTxID = id;
                System.out.println("Transaction ID: " + this.latestTxID);
                // Increment nonce for next transaction
                this.nonce++;
            } else {
                throw new Exception("Certificate submission failed: " + responseData.get("Response"));
            }
        }
    }

    // Helper methods for signature encoding
    private static byte[] toDERFormat(BigInteger r, BigInteger s) {
        // DER format: 0x30 [total-length] 0x02 [r-length] [r] 0x02 [s-length] [s]
        byte[] rBytes = r.toByteArray();
        byte[] sBytes = s.toByteArray();

        // Ensure positive numbers by prepending 0x00 if needed
        if (rBytes[0] < 0) {
            byte[] temp = new byte[rBytes.length + 1];
            temp[0] = 0;
            System.arraycopy(rBytes, 0, temp, 1, rBytes.length);
            rBytes = temp;
        }
        if (sBytes[0] < 0) {
            byte[] temp = new byte[sBytes.length + 1];
            temp[0] = 0;
            System.arraycopy(sBytes, 0, temp, 1, sBytes.length);
            sBytes = temp;
        }

        int totalLength = 2 + rBytes.length + 2 + sBytes.length;
        byte[] derSignature = new byte[2 + totalLength];
        
        // Sequence tag
        derSignature[0] = 0x30;
        // Total length
        derSignature[1] = (byte) totalLength;
        // Integer tag for r
        derSignature[2] = 0x02;
        // r length
        derSignature[3] = (byte) rBytes.length;
        // r value
        System.arraycopy(rBytes, 0, derSignature, 4, rBytes.length);
        // Integer tag for s
        derSignature[4 + rBytes.length] = 0x02;
        // s length
        derSignature[5 + rBytes.length] = (byte) sBytes.length;
        // s value
        System.arraycopy(sBytes, 0, derSignature, 6 + rBytes.length, sBytes.length);

        return derSignature;
    }

    private static String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02x", b));
        }
        return result.toString();
    }

    // Getters and setters
    public String getLastError() {
        return lastError;
    }

    public void setNagUrl(String nagUrl) {
        this.nagUrl = nagUrl;
    }

    public void setNetworkNode(String networkNode) {
        this.networkNode = networkNode;
    }

    public String getLatestTxID() {
        return latestTxID;
    }

    public void setLatestTxID(String latestTxID) {
        this.latestTxID = latestTxID;
    }

    public long getNonce() {
        return nonce;
    }

    public void setNonce(long nonce) {
        this.nonce = nonce;
    }

    public int getIntervalSec() {
        return intervalSec;
    }

    public void setIntervalSec(int intervalSec) {
        this.intervalSec = intervalSec;
    }
}
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 CIRCULAR GLOBAL LEDGERS, INC.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="src/test/java/circular/enterprise/apis/IntegrationTest.java">
package circular.enterprise.apis;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import java.util.Map;

public class IntegrationTest {
    private static final String PRIVATE_KEY = System.getenv("CIRCULAR_PRIVATE_KEY") != null ? System.getenv("CIRCULAR_PRIVATE_KEY") : ""; // Replace with your private key
    private static final String ADDRESS = System.getenv("CIRCULAR_ADDRESS") != null ? System.getenv("CIRCULAR_ADDRESS") : ""; // Replace with your wallet address
    private CEPAccount account;

    @BeforeEach
    void setUp() {
        // Skip tests if environment variables are not set
        if (PRIVATE_KEY == null || PRIVATE_KEY.isEmpty() || ADDRESS == null || ADDRESS.isEmpty()) {
            System.out.println("Skipping tests: CIRCULAR_PRIVATE_KEY and CIRCULAR_ADDRESS environment variables must be set");
            return;
        }
        account = new CEPAccount();
    }

    @Test
    void testCircularOperations() throws Exception {
        // Skip test if environment variables are not set
        if (PRIVATE_KEY == null || PRIVATE_KEY.isEmpty() || ADDRESS == null || ADDRESS.isEmpty()) {
            return;
        }

        // Open account
        assertTrue(account.open(ADDRESS));
        
        // Set network to testnet and configure NAG URL
        String networkUrl = account.setNetwork("testnet");
        assertNotNull(networkUrl);
        
        // Update account to get current nonce
        assertTrue(account.updateAccount());
        
        // Create a test message and sign it
        String message = "Test message from Java implementation";
        
        // Create and submit a certificate
        String certificateData = String.format(
            "{\"message\":\"%s\"}",
            message,
        );
        
        account.submitCertificate(certificateData, PRIVATE_KEY);
        
        // Wait for transaction to be processed
        String txId = account.getLatestTxID();
        if (txId != null && !txId.isEmpty()) {
            Map<String, Object> outcome = account.getTransactionOutcome(txId, 30, 2);
            assertEquals(200, outcome.get("Result"));
            Map<String, Object> resp = (Map<String, Object>) outcome.get("Response");
            String blockID = (String) response.get("BlockID");
            
            // Query the transaction
            Map<String, Object> txData = account.getTransactiond(blockID, txId);
            assertEquals(200, txData.get("Result"));
        }
    }

    @Test
    void testCertificateOperations() throws Exception {
        // Skip test if environment variables are not set
        if (PRIVATE_KEY == null || PRIVATE_KEY.isEmpty() || ADDRESS == null || ADDRESS.isEmpty()) {
            return;
        }

        // Open account first
        assertTrue(account.open(ADDRESS));
        String networkUrl = account.setNetwork("testnet");
        
        // Create and submit a test certificate
        String certificateData = "{\"test\":\"data\",\"timestamp\":\"" + System.currentTimeMillis() + "\"}";
        
        // Test certificate submission
        assertDoesNotThrow(() -> {
            account.submitCertificate(certificateData, PRIVATE_KEY);
        }, "Certificate submission should not throw an exception");
        
        // If a transaction ID is available, test transaction query
        String txId = account.getLatestTxID();
        if (txId != null && !txId.isEmpty()) {
            Map<String, Object> txData = account.getTransactionById(txId, 0, 10);
            assertNotNull(txData, "Transaction data should not be null");
            assertEquals(200, txData.get("Result"), "Transaction query should be successful");
        }
    }

    @Test
    void testHelloWorldCertification() throws Exception {
        // Skip test if environment variables are not set
        if (PRIVATE_KEY == null || PRIVATE_KEY.isEmpty() || ADDRESS == null || ADDRESS.isEmpty()) {
            return;
        }

        // Open account
        assertTrue(account.open(ADDRESS));
        System.out.println("Account opened successfully");
        
        // Set network to testnet and configure NAG URL
        String networkUrl = account.setNetwork("testnet");
        assertNotNull(networkUrl);
        System.out.println("Connected to testnet: " + networkUrl);
        
        // Update account to get current nonce
        assertTrue(account.updateAccount());
        System.out.println("Account updated, current nonce: " + account.getNonce());
        
        // Create and sign "Hello World" message
        String message = "Hello World";
        
        // Create and submit the certificate
        String certificateData = String.format(
            "{\"message\":\"%s\",\"timestamp\":%d}",
            message,
            System.currentTimeMillis()
        );
        
        System.out.println("Submitting certificate: " + certificateData);
        account.submitCertificate(certificateData, PRIVATE_KEY);
        
        // Get and save the transaction ID with retries
        String txId = null;
        int maxRetries = 5;
        int retryCount = 0;
        while (txId == null || txId.isEmpty()) {
            txId = account.getLatestTxID();
            if (txId == null || txId.isEmpty()) {
                if (retryCount >= maxRetries) {
                    fail("Failed to get transaction ID after " + maxRetries + " attempts");
                }
                System.out.println("Transaction ID not available yet, retrying in 2 seconds...");
                Thread.sleep(2000);
                retryCount++;
            }
        }
        System.out.println("Transaction ID: " + txId);
        
        // Wait for transaction to be processed and get outcome (increased timeout to 120 seconds)
        System.out.println("Waiting for transaction to be processed...");
        Map<String, Object> outcome = account.getTransactionOutcome(txId, 120, 5);
        assertEquals(200, outcome.get("Result"), "Transaction should be successful");
        System.out.println("Transaction processed successfully");
        
        // Get the block number from the transaction response
        Map<String, Object> response = (Map<String, Object>) outcome.get("Response");
        System.out.println("Transaction response: " + response);
        assertNotNull(response, "Transaction response should not be null");

        String blockID = (String) response.get("BlockID");
        assertNotNull(blockID, "Block number should not be null");
        System.out.println("Block number: " + blockID);
        
        // Query the transaction directly using block number
        Map<String, Object> txData = account.getTransaction(blockID, txId);
        assertEquals(200, txData.get("Result"), "Direct transaction query should be successful");
        System.out.println("Transaction verified in block: " + blockID);
        
        // Print full transaction details
        System.out.println("Transaction details: " + txData.get("Response"));

        account.close();
    }
}
</file>

<file path="README.md">
# Circular Enterprise APIs - Java Implementation

Official Circular Protocol Enterprise APIs for Data Certification - Java Implementation

## Features

- Account management and blockchain interaction
- Certificate creation and submission
- Transaction tracking and verification
- Secure digital signatures using ECDSA (secp256k1)
- RFC 6979 compliant deterministic signatures

## Requirements

- Java 11 or higher
- Maven 3.6 or higher

## Dependencies

- OkHttp3 for HTTP requests
- Jackson for JSON processing
- Bouncy Castle for cryptographic operations
- JUnit Jupiter for testing

## Installation

1. Clone the repository
2. Build with Maven:
```bash
mvn clean install
```

## Usage Example



## API Documentation

### CEPAccount Class

Main class for interacting with the Circular blockchain:

- `open(String address)` - Open an account
- `updateAccount()` - Update account data and nonce
- `setNetwork(String network)` - Set blockchain network
- `signData(String message, String privateKeyHex)` - Sign data with private key
- `submitCertificate(String data, String privateKeyHex)` - Submit a certificate
- `getTransactionById(String txId, long start, long end)` - Get transaction details
- `getTransactionOutcome(String txId, int timeoutSec, int intervalSec)` - Poll for transaction outcome

### CCertificate Class

Class for managing certificates:

- `setData(String data)` - Set certificate data
- `getData()` - Get certificate data
- `getJsonCertificate()` - Get certificate in JSON format
- `getCertificateSize()` - Get certificate size in bytes

## Testing

To run the tests, you need to set up the following environment variables:

```bash
export CIRCULAR_PRIVATE_KEY="your_64_character_private_key_here"
export CIRCULAR_ADDRESS="your_wallet_address_here"
```

The private key should be a 64-character (32-byte) hex string, and the address should be a valid Ethereum-style address (40 characters + 0x prefix).

### Running Tests

```bash
mvn clean test
```

## Building

```bash
mvn clean package
```

## License

MIT License - see LICENSE file for details

## Credits

CIRCULAR GLOBAL LEDGERS, INC. - USA

- Original JS Version: Gianluca De Novi, PhD
- Java Implementation: Danny De Novi
</file>

</files>
