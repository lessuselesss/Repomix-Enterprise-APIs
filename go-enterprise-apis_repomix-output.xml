This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    tests_all.yml
internal/
  utils/
    utils_test.go
    utils.go
pkg/
  account_test.go
  account.go
  certificate_test.go
  certificate.go
  circular_enterprise_apis_test.go
  circular_enterprise_apis.go
tests/
  e2e/
    .keep
    e2e_test.go
  integration/
    .keep
    circular_enterprise_apis_integration_test.go
.gitignore
AUDIT_FINDINGS.md
e2e_testing_plan.md
go_nodejs_alignment_plan.md
go-enterprise-apis_repomix-output.xml
go.mod
main.go
new_audit_findings.md
nodejs_go_audit_findings.md
README.md
recommendations-account_test.md
RFC-6979.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="tests/e2e/e2e_test.go">
//go:build e2e

package e2e

import (
	"fmt"
	"os"
	"testing"
	"time"

	"github.com/joho/godotenv"
	cep "github.com/lessuselesss/CEP-Go-APIs/pkg"
)

var (
	privateKeyHex string
	address      string
)

func TestMain(m *testing.M) {
	// Load .env.e2e file from the project root
	if err := godotenv.Load("../../.env.e2e"); err != nil {
		fmt.Println("No .env.e2e file found, falling back to .env")
		// If .env.e2e is not found, try to load .env from the project root
		if err := godotenv.Load("../../.env"); err != nil {
			fmt.Println("Error loading .env file, tests requiring env vars will be skipped.")
		}
	}

	privateKeyHex = os.Getenv("E2E_PRIVATE_KEY")
	address = os.Getenv("E2E_ADDRESS")

	// Run the tests
	os.Exit(m.Run())
}

func TestE2ECircularOperations(t *testing.T) {
	if privateKeyHex == "" || address == "" {
		t.Skip("Skipping E2E test: CIRCULAR_PRIVATE_KEY and CIRCULAR_ADDRESS environment variables must be set")
	}

	acc := cep.NewCEPAccount("testnet", "1.0")

	err := acc.Open(address)
	if err != nil {
		t.Fatalf("acc.Open() failed: %v", err)
	}

	err = acc.SetNetwork("testnet")
	if err != nil {
		t.Fatalf("acc.SetNetwork() failed: %v", err)
	}

	ok, err := acc.UpdateAccount()
	if !ok || err != nil {
		t.Fatalf("acc.UpdateAccount() failed: ok=%v, err=%v", ok, err)
	}

	resp, err := acc.SubmitCertificate("test message from Go E2E test", privateKeyHex)
	if err != nil {
		t.Fatalf("acc.SubmitCertificate() failed: %v", err)
	}

	txHash, ok := resp["txHash"].(string)
	if !ok {
		t.Fatal("txHash not found in response")
	}

	// Poll for transaction outcome
	var outcome map[string]interface{}
	for i := 0; i < 10; i++ {
		outcome, err = acc.GetTransactionOutcome(txHash, 10)
		if err == nil && outcome != nil {
			if status, ok := outcome["Status"].(string); ok && status == "Confirmed" {
				break
			}
		}
		time.Sleep(2 * time.Second)
	}

	if err != nil {
		t.Fatalf("acc.GetTransactionOutcome() failed: %v", err)
	}

	if status, _ := outcome["Status"].(string); status != "Confirmed" {
		t.Errorf("Expected transaction status to be 'Confirmed', but got '%s'", status)
	}
}

func TestE2ECertificateOperations(t *testing.T) {
	if privateKeyHex == "" || address == "" {
		t.Skip("Skipping E2E test: CIRCULAR_PRIVATE_KEY and CIRCULAR_ADDRESS environment variables must be set")
	}

	acc := cep.NewCEPAccount("testnet", "1.0")

	err := acc.Open(address)
	if err != nil {
		t.Fatalf("acc.Open() failed: %v", err)
	}

	err = acc.SetNetwork("testnet")
	if err != nil {
		t.Fatalf("acc.SetNetwork() failed: %v", err)
	}

	_, err = acc.UpdateAccount()
	if err != nil {
		t.Fatalf("acc.UpdateAccount() failed: %v", err)
	}

	resp, err := acc.SubmitCertificate("{\"test\":\"data\"}", privateKeyHex)
	if err != nil {
		t.Fatalf("acc.SubmitCertificate() failed: %v", err)
	}

	txHash, ok := resp["txHash"].(string)
	if !ok {
		t.Fatal("txHash not found in response")
	}

	// Poll for transaction outcome
	var outcome map[string]interface{}
	for i := 0; i < 10; i++ {
		outcome, err = acc.GetTransactionOutcome(txHash, 10)
		if err == nil && outcome != nil {
			if status, ok := outcome["Status"].(string); ok && status == "Confirmed" {
				break
			}
		}
		time.Sleep(2 * time.Second)
	}

	if err != nil {
		t.Fatalf("acc.GetTransactionOutcome() failed: %v", err)
	}

	if status, _ := outcome["Status"].(string); status != "Confirmed" {
		t.Errorf("Expected transaction status to be 'Confirmed', but got '%s'", status)
	}
}

func TestE2EHelloWorldCertification(t *testing.T) {
	if privateKeyHex == "" || address == "" {
		t.Skip("Skipping E2E test: CIRCULAR_PRIVATE_KEY and CIRCULAR_ADDRESS environment variables must be set")
	}

	acc := cep.NewCEPAccount("testnet", "1.0")

	err := acc.Open(address)
	if err != nil {
		t.Fatalf("acc.Open() failed: %v", err)
	}

	err = acc.SetNetwork("testnet")
	if err != nil {
		t.Fatalf("acc.SetNetwork() failed: %v", err)
	}

	_, err = acc.UpdateAccount()
	if err != nil {
		t.Fatalf("acc.UpdateAccount() failed: %v", err)
	}

	resp, err := acc.SubmitCertificate("Hello World", privateKeyHex)
	if err != nil {
		t.Fatalf("acc.SubmitCertificate() failed: %v", err)
	}

	txHash, ok := resp["txHash"].(string)
	if !ok {
		t.Fatal("txHash not found in response")
	}

	// Poll for transaction outcome
	var outcome map[string]interface{}
	for i := 0; i < 10; i++ {
		outcome, err = acc.GetTransactionOutcome(txHash, 10)
		if err == nil && outcome != nil {
			if status, ok := outcome["Status"].(string); ok && status == "Confirmed" {
				break
			}
		}
		time.Sleep(2 * time.Second)
	}

	if err != nil {
		t.Fatalf("acc.GetTransactionOutcome() failed: %v", err)
	}

	if status, _ := outcome["Status"].(string); status != "Confirmed" {
		t.Errorf("Expected transaction status to be 'Confirmed', but got '%s'", status)
	}
}
</file>

<file path="AUDIT_FINDINGS.md">
# Go-lang vs. Node.js Implementation Audit Findings

This document outlines the differences in logic and dependencies between the Go-lang and Node.js implementations of the Circular Enterprise Protocol (CEP) APIs.

### 1.5 `hexToString` (Node.js) vs. `HexToString` (Go)

*   **Node.js (`reference-nodejs-implementation.js`):**
    ```javascript
    function hexToString(hex) {
        var str = '';
        hex = HexFix(hex);
        for (var i = 0; i < hex.length; i += 2) {
            var code = parseInt(hex.substr(i, 2), 16);
            if (!isNaN(code) && code !== 0) {
                str += String.fromCharCode(code);
            }
        }
        return str;
    }
    ```
    *   **Dependencies:** `HexFix` (local helper function).

*   **Go (`internal/utils/utils.go`):**
    ```go
    func HexToString(hexStr string) string {
        cleanedHex := HexFix(hexStr)
        bytes, err := hex.DecodeString(cleanedHex)
        if err != nil {
            return ""
        }
        // Strip null bytes to match the reference implementation
        return strings.ReplaceAll(string(bytes), "\x00", "")
    }
    ```
    *   **Dependencies:** `encoding/hex` package, `strings` package, `HexFix` (local helper function).

*   **Logic Difference:** Both convert a hexadecimal string back to its original string form. The Node.js version manually parses the hex string, while the Go version uses `hex.DecodeString`. The Go version also explicitly strips null bytes (`\x00`) to match the behavior of the Node.js implementation, which implicitly handles them due to `String.fromCharCode` behavior with `0`.

## 2. Certificate Class

### 2.1 `C_CERTIFICATE` (Node.js) vs. `Certificate` (Go) Structure

*   **Node.js (`reference-nodejs-implementation.js`):**
    ```javascript
    export class C_CERTIFICATE {
      
        constructor() {
            this.data = null;
            this.previousTxID = null;
            this.previousBlock = null;
        }
    ...
    }
    ```
    *   **Dependencies:** None.

*   **Go (`pkg/certificate/certificate.go`):**
    ```go
    type Certificate struct {
        Data          string `json:"data"`
        PreviousTxID  string `json:"previousTxID"`
        PreviousBlock string `json:"previousBlock"`
        Version       string `json:"version"`
    }
    ```
    *   **Dependencies:** None.

*   **Logic Difference:** The Go `Certificate` struct includes a `Version` field, which is not explicitly present as a field in the Node.js `C_CERTIFICATE` class constructor. However, the Node.js `getJSONCertificate` and `getCertificateSize` methods *do* include a `version` field in the JSON output, which is taken from `this.codeVersion` (a global `LIB_VERSION`). This indicates a slight structural difference in how the version is managed, but the serialized output is intended to be similar.

### 2.2 `setData` (Node.js) vs. `SetData` (Go)

*   **Node.js (`reference-nodejs-implementation.js`):**
    ```javascript
    setData(data)
    {
         this.data = stringToHex(data);    
    }
    ```
    *   **Dependencies:** `stringToHex` (local helper function).

*   **Go (`pkg/certificate/certificate.go`):**
    ```go
    func (c *Certificate) SetData(data string) {
        c.Data = hex.EncodeToString([]byte(data))
    }
    ```
    *   **Dependencies:** `encoding/hex` package.

*   **Logic Difference:** Functionally identical. Both convert the input string `data` to its hexadecimal representation and store it in the `data` field of the certificate. The Node.js version uses its local `stringToHex` helper, while the Go version directly uses `hex.EncodeToString`.

### 2.5 `getCertificateSize` (Node.js) vs. `GetCertificateSize` (Go)

*   **Node.js (`reference-nodejs-implementation.js`):**
    ```javascript
    getCertificateSize() {
        let certificate = {
            "data": data,
            "previousTxID": this.previousTxID,
            "previousBlock": this.previousBlock,
            "version": this.codeVersion
        };
        const jsonString = JSON.stringify(certificate);
        return Buffer.byteLength(jsonString, 'utf8');
    }
    ```
    *   **Dependencies:** `JSON.stringify` (built-in), `Buffer.byteLength` (Node.js Buffer API).

*   **Go (`pkg/certificate/certificate.go`):**
    ```go
    func (c *Certificate) GetCertificateSize() (int, error) {
        // The json.Marshal function converts the struct into a JSON byte slice.
        jsonBytes, err := json.Marshal(c)
        if err != nil {
            // Using fmt.Errorf to wrap the original error with more context.
            return 0, fmt.Errorf("failed to marshal certificate to JSON: %w", err)
        }
        // The length of the byte slice is the size of the certificate in bytes.
        return len(jsonBytes), nil
    }
    ```
    *   **Dependencies:** `encoding/json` package, `fmt` package.

*   **Logic Difference:** Both calculate the size of the JSON-serialized certificate in bytes. Similar to `getJSONCertificate`, the Node.js version manually constructs the object and uses `Buffer.byteLength`, while the Go version uses `json.Marshal` and then `len()` on the resulting byte slice. The Node.js version again uses an undefined `data` variable, which is a bug. The Go version correctly uses `c.Data`.

## 3. Account Class

### 3.1 `CEP_Account` (Node.js) vs. `CEPAccount` (Go) Structure and Constructor

*   **Node.js (`reference-nodejs-implementation.js`):**
    ```javascript
    export class CEP_Account {

        constructor() {
            this.address = null;
            this.publicKey = null;
            this.info = null;
            this.codeVersion = LIB_VERSION;
            this.lastError='';
            this.NAG_URL = DEFAULT_NAG;
            this.NETWORK_NODE = '';
            this.blockchain = DEFAULT_CHAIN;
            this.LatestTxID = '';
            this.Nonce = 0;
            this.data = {};
            this.intervalSec = 2;
        }
    ...
    }
    ```
    *   **Dependencies:** `LIB_VERSION`, `DEFAULT_NAG`, `DEFAULT_CHAIN` (global constants).

*   **Go (`pkg/account/account.go`):**
    ```go
    type CEPAccount struct {
        Address     string
        PublicKey   string
        Info        interface{}
        CodeVersion string
        LastError   string
        NAGURL      string
        NetworkNode string
        Blockchain  string
        LatestTxID  string
        Nonce       int
        Data        map[string]interface{}
        IntervalSec int
        NetworkURL  string
        PrivateKey  *secp256k1.PrivateKey
    }

    func NewCEPAccount() *CEPAccount {
        return &CEPAccount{
            CodeVersion: "1.0.13",
            NAGURL:      "https://nag.circularlabs.io/NAG.php?cep=",
            Blockchain:  "0x8a20baa40c45dc5055aeb26197c203e576ef389d9acb171bd62da11dc5ad72b2",
            Nonce:       0,
            Data:        make(map[string]interface{}),
            IntervalSec: 2,
        }
    }
    ```
    *   **Dependencies:** `secp256k1` (for `PrivateKey` type).

*   **Logic Difference:** Both define the structure and initialize default values for an account. The Go version uses a `NewCEPAccount` factory function for initialization, which is idiomatic Go. The Go `CEPAccount` struct also includes a `NetworkURL` field and a `PrivateKey` field, which are not directly present in the Node.js `CEP_Account` constructor's initial assignments, though `PrivateKey` is used in `signData` in Node.js. The `CodeVersion`, `NAGURL`, `Blockchain` are hardcoded in the Go `NewCEPAccount` function, while in Node.js they refer to global constants.

### 3.3 `updateAccount` (Node.js) vs. `UpdateAccount` (Go)

*   **Node.js (`reference-nodejs-implementation.js`):**
    ```javascript
    async updateAccount() {
        if (!this.address) {
            throw new Error("Account is not open");
        }

        let data = {
            "Blockchain": HexFix(this.blockchain),
            "Address": HexFix(this.address),
            "Version": this.codeVersion
        };

        try {
            const response = await fetch(this.NAG_URL + 'Circular_GetWalletNonce_' + this.NETWORK_NODE, {
                method: 'POST',
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(data),
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const jsonResponse = await response.json();

            if (jsonResponse.Result === 200 && jsonResponse.Response && jsonResponse.Response.Nonce !== undefined) {
                this.Nonce = jsonResponse.Response.Nonce + 1;
                return true;
            } else {
                throw new Error('Invalid response format or missing Nonce field');
            }
        } catch (error) {
            console.error('Error:', error);
            return false;
        }
    }
    ```
    *   **Dependencies:** `HexFix` (local helper function), `fetch` (Node.js built-in/global), `JSON.stringify` (built-in).

*   **Go (`pkg/account/account.go`):**
    ```go
    func (a *CEPAccount) UpdateAccount() (bool, error) {
        if a.Address == "" {
            return false, errors.New("Account is not open")
        }

        // Prepare the request payload
        requestData := struct {
            Blockchain string `json:"Blockchain"`
            Address    string `json:"Address"`
            Version    string `json:"Version"`
        }{
            Blockchain: utils.HexFix(a.Blockchain),
            Address:    utils.HexFix(a.Address),
            Version:    a.CodeVersion,
        }

        jsonData, err := json.Marshal(requestData)
        if err != nil {
            return false, fmt.Errorf("failed to marshal request data: %w", err)
        }

        // Construct the full URL for the API endpoint
        url := a.NAGURL + "Circular_GetWalletNonce_" + a.NetworkNode

        // Make the HTTP POST request
        resp, err := http.Post(url, "application/json", bytes.NewBuffer(jsonData))
        if err != nil {
            return false, fmt.Errorf("http post request failed: %w", err)
        }
        defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK {
            return false, fmt.Errorf("network request failed with status: %s", resp.Status)
        }

        // Decode the JSON response
        var responseData struct {
            Result   int `json:"Result"`
            Response struct {
                Nonce int `json:"Nonce"`
            } `json:"Response"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&responseData); err != nil {
            return false, fmt.Errorf("failed to decode response body: %w", err)
        }

        // Check for a successful result and update the nonce
        if responseData.Result == 200 {
            a.Nonce = responseData.Response.Nonce + 1
            return true, nil
        }

        return false, errors.New("failed to update account, invalid response from server")
    }
    ```
    *   **Dependencies:** `errors` package, `encoding/json` package, `bytes` package, `net/http` package, `fmt` package, `utils.HexFix` (internal utility).

*   **Logic Difference:** Both methods update the account's nonce by making a POST request to the NAG. The Node.js version uses `fetch` and `JSON.stringify`, while the Go version uses `net/http` and `json.Marshal`/`json.NewDecoder`. Error handling is done via `try-catch` in Node.js and `error` returns in Go. The Go version explicitly defines the structure of the request and response JSON, while Node.js relies on dynamic object creation.

### 3.10 `GetTransactionOutcome` (Node.js) vs. `GetTransactionOutcome` (Go)

*   **Node.js (`reference-nodejs-implementation.js`):**
    ```javascript
    async GetTransactionOutcome(TxID, timeoutSec) {
        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            const interval = this.intervalSec * 1000;  // Convert seconds to milliseconds
            const timeout = timeoutSec * 1000;    // Convert seconds to milliseconds

            const checkTransaction = () => {
                const elapsedTime = Date.now() - startTime;
                
                console.log('Checking transaction...', { elapsedTime, timeout });

                if (elapsedTime > timeout) {
                    console.log('Timeout exceeded');
                    reject(new Error('Timeout exceeded'));
                    return;
                }

                this.getTransactionbyID(TxID, 0, 10).then(data => {
                        console.log('Data received:', data);
                        if (data.Result === 200 && data.Response !== 'Transaction Not Found' && data.Response.Status!=='Pending') {
                            resolve(data.Response);  // Resolve if transaction is found and not 'Transaction Not Found'
                        } else {
                            console.log('Transaction not yet confirmed or not found, polling again...');
                            setTimeout(checkTransaction, interval);  // Continue polling
                        }
                    })
                    .catch(error => {
                        console.log('Error fetching transaction:', error);
                        reject(error);  // Reject on error
                    });
            };

            setTimeout(checkTransaction, interval);  // Start polling
        });
    }
    ```
    *   **Dependencies:** `Promise` (built-in), `Date.now` (built-in), `setTimeout` (built-in), `this.intervalSec` (instance property), `this.getTransactionbyID` (local method).

*   **Go (`pkg/account/account.go`):**
    ```go
    func (a *CEPAccount) GetTransactionOutcome(transactionID string) (map[string]interface{}, error) {
        // The Network Access Gateway URL must be set to know which network to query.
        if a.NAGURL == "" {
            return nil, fmt.Errorf("network is not set. Please call SetNetwork() first")
        }

        // Construct the full API endpoint URL for fetching the transaction outcome.
        requestURL := fmt.Sprintf("%s/transaction/outcome/%s", a.NAGURL, transactionID)

        // Perform an HTTP GET request to the specified endpoint.
        resp, err := http.Get(requestURL)
        if err != nil {
            return nil, fmt.Errorf("failed to send get transaction outcome request: %w", err)
        }
        defer resp.Body.Close()

        // Check for a successful HTTP response. A non-200 status indicates a problem.
        if resp.StatusCode != http.StatusOK {
            return nil, fmt.Errorf("network returned an error: %s", resp.Status)
        }

        // Read the entire body of the HTTP response.
        body, err := io.ReadAll(resp.Body)
        if err != nil {
            return nil, fmt.Errorf("failed to read response body: %w", err)
        }

        // Unmarshal the JSON response into a map. Using a map allows for flexible handling
        // of various outcome structures returned by the network.
        var outcomeDetails map[string]interface{}
        if err := json.Unmarshal(body, &outcomeDetails); err != nil {
            return nil, fmt.Errorf("failed to decode transaction outcome: %w", err)
        }

        return outcomeDetails, nil
    }
    ```
    *   **Dependencies:** `fmt` package, `net/http` package, `io` package, `encoding/json` package.

*   **Logic Difference:** This is another significant difference. The Node.js `GetTransactionOutcome` implements a polling mechanism with a timeout, repeatedly calling `getTransactionbyID` until the transaction is found and its status is not 'Pending' or a timeout occurs. The Go `GetTransactionOutcome` method, however, makes a single HTTP GET request to a dedicated `/transaction/outcome/{id}` endpoint. This implies that the Go implementation relies on the server-side to handle the polling or provide immediate transaction outcome, whereas the Node.js version handles the polling client-side. The Go version is simpler as it expects the outcome to be available directly from the endpoint.

## 4. CEP Class

### 4.4 `GetNAG` (Node.js) vs. `GetNAG` (Go)

*   **Node.js (`reference-nodejs-implementation.js`):**
    ```javascript
    async GetNAG(network) {
        try {
            const response = await fetch(NETWORK_URL + network);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.text();
            return data;
        } catch (error) {
            console.error("Error fetching NAG:", error);
            throw error;
        }
    }
    ```
    *   **Dependencies:** `NETWORK_URL` (global constant), `fetch` (Node.js built-in/global).

*   **Go (`pkg/circular_enterprise_apis.go`):**
    ```go
    func GetNAG(network string) (string, error) {
        resp, err := http.Get(NetworkURL + network)
        if err != nil {
            return "", err
        }
        defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil {
            return "", err
        }

        return string(body), nil
    }
    ```
    *   **Dependencies:** `net/http` package, `io` package, `NetworkURL` (global constant).

*   **Logic Difference:** Both methods fetch the NAG URL for a given network. The Node.js version uses `fetch` and handles errors with `try-catch`. The Go version uses `net/http.Get` and returns an error. Both append the network to a global `NETWORK_URL` constant. The Node.js version is an instance method, while the Go version is a standalone function.
</file>

<file path="e2e_testing_plan.md">
# E2E Testing Plan

End-to-End (E2E) tests are designed to be run against a live, deployed infrastructure (like a testnet or staging environment). This is a crucial step to ensure your code works in a real-world scenario.

### Where to Put the Logic

The ideal place for these tests is already set up in your project structure: the **`tests/e2e/`** directory.

We would create a new file, for example: `tests/e2e/live_infra_test.go`.

This separation is important because:
1.  **Speed:** E2E tests are much slower than unit or integration tests because they involve real network latency.
2.  **Environment Dependency:** They require a live environment to be running and properly configured.
3.  **Cost/State:** They can potentially cost money (if using a paid service) and change the state of the blockchain or application you're testing against.

### How to Start Testing It

Here is the plan to implement and run these E2E tests:

1.  **Configuration:** We'll need to configure the tests to point to the live infrastructure. This is done securely using environment variables, just like the integration test. We would add new variables to your `.env` file (or a new `.env.e2e` file) for the live testnet URL and any required credentials.
    *   `E2E_NAG_URL="https://<your-live-testnet-nag-url>"`
    *   `E2E_PRIVATE_KEY="..."`
    *   `E2E_ADDRESS="..."`

2.  **Create the E2E Test File:** I will create `tests/e2e/live_infra_test.go`. This file will be very similar to the integration test, but instead of creating a mock server, it will connect to the `E2E_NAG_URL`.

3.  **Use Go Build Tags:** To prevent these slow E2E tests from running every time you execute `go test ./...`, we'll use a Go build tag. We'll add this comment at the top of the E2E test file:
    ```go
    //go:build e2e
    ```
    This tells the Go compiler to only include this file in the build if you explicitly ask for the `e2e` tag.

4.  **Running the E2E Tests:** You would then run these specific tests with a special command:
    ```bash
    go test -v -tags=e2e ./tests/e2e/...
    ```

This approach gives you a robust testing strategy: fast unit tests for local development, slightly slower integration tests for checking component interactions, and separate, deliberate E2E tests to validate against a live system.
</file>

<file path="go_nodejs_alignment_plan.md">
# Go/Node.js API Alignment Plan

This plan outlines the steps to align the Go implementation with the Node.js reference, prioritizing Go idiomatic style and ensuring test conformance.

## Goal:
- Align Go developer experience with Node.js.
- Maintain idiomatic Go API.
- Ensure tests conform to aligned API.

## Progress Tracking:
- **Rule:** A checkbox should not be checked until all nested checkboxes under it are verified and checked.
- [ ] Top-level task
  - [ ] Sub-task

---

## 1. Helper Functions Alignment [x]

- [x] **Timestamp Format Consistency:**
  - [x] Align `GetFormattedTimestamp()` in `pkg/circular_enterprise_apis.go` to return `YYYY:MM:DD-HH:MM:SS` format, consistent with `internal/utils/utils.go` and Node.js.

## 2. Certificate Structure and Operations Alignment [x]

- [x] **Data Encoding in `Certificate.SetData`:**
  - [x] Modify `Certificate.SetData` in `pkg/circular_enterprise_apis.go` to automatically hex-encode the input `data` before storing it, mirroring Node.js behavior.
  - [ ] **Note:** `NewCertificate` and `GetJSONCertificate`/`GetCertificateSize` are already idiomatic Go and will remain as is.

## 3. Account Structure and Operations Alignment [x]

- [x] **Private Key Handling and `SignData`:**
  - [x] Modify `CEPAccount.SignData` in `pkg/account.go` to accept the private key as an argument (`privateKey string`), similar to Node.js.
  - [x] Remove `PrivateKey` field from `CEPAccount` struct if it's no longer needed for signing operations, or clarify its purpose if it remains.
- [x] **`SubmitCertificate` API Alignment:**
  - [x] Modify `CEPAccount.SubmitCertificate` in `pkg/account.go` to accept raw `pdata` (string) and `privateKey` (string) as arguments, similar to Node.js.
  - [x] Implement internal logic within `SubmitCertificate` to:
    - [x] Create the `PayloadObject` and `Payload` (hex-encoded JSON string).
    - [x] Generate `Timestamp` using the consistent format.
    - [x] Construct the `str` for hashing.
    - [x] Generate `ID` using SHA-256.
    - [x] Call `SignData` (with the new signature) to get the `Signature`.
    - [x] Construct the final `data` payload for the HTTP request.
- [x] **`UpdateAccount` API Endpoint Alignment:**
  - [x] Modify `CEPAccount.UpdateAccount` in `pkg/account.go` to append `a.NetworkNode` to the `NAGURL` when calling `Circular_GetWalletNonce_` (or its Go equivalent), if `NetworkNode` is a required part of the endpoint.
- [x] **Transaction Query Endpoints Alignment:**
  - [x] Review Node.js `getTransaction` and `getTransactionbyID` methods and their corresponding API calls (`Circular_GetTransactionbyID_`).
  - [x] Ensure Go's `CEPAccount.GetTransaction` and `CEPAccount.GetTransactionByID` methods correctly map to the expected backend API endpoints and parameter formats, potentially consolidating or adjusting them to match `Circular_GetTransactionbyID_` if it's the primary endpoint for transaction queries.
    - [x] Specifically, ensure Go can query by `TxID`, `Start` block, and `End` block if the Node.js implementation supports this.

## 4. API Endpoints and Communication Alignment [x]

- [x] **Consistent Endpoint Naming:**
  - [x] Modify Go HTTP requests to use the exact endpoint names (e.g., `Circular_GetWalletNonce_`, `Circular_AddTransaction_`, `Circular_GetTransactionbyID_`) if the backend expects these specific names. This might involve changing the `fmt.Sprintf` calls in `pkg/account.go`.

## 5. Test Conformance [x]

- [x] **Update Existing Tests:**
  - [x] Modify `pkg/account_test.go` and `tests/integration/circular_enterprise_apis_integration_test.go` to reflect the changes made to the `CEPAccount` and `Certificate` APIs.
- [x] **Add New Tests (if necessary):**
  - [x] Create new unit or integration tests to cover any new functionality or edge cases introduced by the alignment.
  - [x] Ensure tests cover the new `SubmitCertificate` signature and behavior.
  - [x] Verify transaction query methods work as expected after alignment.

---

## General Notes:
- Go's idiomatic error handling (`error` return values) will be maintained.
- Go's idiomatic struct usage and factory functions (`NewCEPAccount`, `NewCertificate`) will be maintained.
- Cryptographic primitives (SHA-256, secp256k1 ECDSA) are consistent and require no changes.
</file>

<file path="go-enterprise-apis_repomix-output.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    tests_all.yml
internal/
  utils/
    utils_test.go
    utils.go
pkg/
  account_test.go
  account.go
  certificate_test.go
  certificate.go
  circular_enterprise_apis_test.go
  circular_enterprise_apis.go
tests/
  e2e/
    .keep
    e2e_test.go
  integration/
    .keep
    circular_enterprise_apis_integration_test.go
.gitignore
AUDIT_FINDINGS.md
e2e_testing_plan.md
go_nodejs_alignment_plan.md
go.mod
main.go
new_audit_findings.md
nodejs_go_audit_findings.md
README.md
recommendations-account_test.md
RFC-6979.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="tests/e2e/e2e_test.go">
//go:build e2e

package e2e

import (
	"fmt"
	"os"
	"testing"
	"time"

	"github.com/joho/godotenv"
	cep "github.com/lessuselesss/CEP-Go-APIs/pkg"
)

var (
	privateKeyHex string
	address      string
)

func TestMain(m *testing.M) {
	// Load .env.e2e file from the project root
	if err := godotenv.Load("../../.env.e2e"); err != nil {
		fmt.Println("No .env.e2e file found, falling back to .env")
		// If .env.e2e is not found, try to load .env from the project root
		if err := godotenv.Load("../../.env"); err != nil {
			fmt.Println("Error loading .env file, tests requiring env vars will be skipped.")
		}
	}

	privateKeyHex = os.Getenv("E2E_PRIVATE_KEY")
	address = os.Getenv("E2E_ADDRESS")

	// Run the tests
	os.Exit(m.Run())
}

func TestE2ECircularOperations(t *testing.T) {
	if privateKeyHex == "" || address == "" {
		t.Skip("Skipping E2E test: CIRCULAR_PRIVATE_KEY and CIRCULAR_ADDRESS environment variables must be set")
	}

	acc := cep.NewCEPAccount("testnet", "1.0")

	err := acc.Open(address)
	if err != nil {
		t.Fatalf("acc.Open() failed: %v", err)
	}

	err = acc.SetNetwork("testnet")
	if err != nil {
		t.Fatalf("acc.SetNetwork() failed: %v", err)
	}

	ok, err := acc.UpdateAccount()
	if !ok || err != nil {
		t.Fatalf("acc.UpdateAccount() failed: ok=%v, err=%v", ok, err)
	}

	resp, err := acc.SubmitCertificate("test message from Go E2E test", privateKeyHex)
	if err != nil {
		t.Fatalf("acc.SubmitCertificate() failed: %v", err)
	}

	txHash, ok := resp["txHash"].(string)
	if !ok {
		t.Fatal("txHash not found in response")
	}

	// Poll for transaction outcome
	var outcome map[string]interface{}
	for i := 0; i < 10; i++ {
		outcome, err = acc.GetTransactionOutcome(txHash, 10)
		if err == nil && outcome != nil {
			if status, ok := outcome["Status"].(string); ok && status == "Confirmed" {
				break
			}
		}
		time.Sleep(2 * time.Second)
	}

	if err != nil {
		t.Fatalf("acc.GetTransactionOutcome() failed: %v", err)
	}

	if status, _ := outcome["Status"].(string); status != "Confirmed" {
		t.Errorf("Expected transaction status to be 'Confirmed', but got '%s'", status)
	}
}

func TestE2ECertificateOperations(t *testing.T) {
	if privateKeyHex == "" || address == "" {
		t.Skip("Skipping E2E test: CIRCULAR_PRIVATE_KEY and CIRCULAR_ADDRESS environment variables must be set")
	}

	acc := cep.NewCEPAccount("testnet", "1.0")

	err := acc.Open(address)
	if err != nil {
		t.Fatalf("acc.Open() failed: %v", err)
	}

	err = acc.SetNetwork("testnet")
	if err != nil {
		t.Fatalf("acc.SetNetwork() failed: %v", err)
	}

	_, err = acc.UpdateAccount()
	if err != nil {
		t.Fatalf("acc.UpdateAccount() failed: %v", err)
	}

	resp, err := acc.SubmitCertificate("{\"test\":\"data\"}", privateKeyHex)
	if err != nil {
		t.Fatalf("acc.SubmitCertificate() failed: %v", err)
	}

	txHash, ok := resp["txHash"].(string)
	if !ok {
		t.Fatal("txHash not found in response")
	}

	// Poll for transaction outcome
	var outcome map[string]interface{}
	for i := 0; i < 10; i++ {
		outcome, err = acc.GetTransactionOutcome(txHash, 10)
		if err == nil && outcome != nil {
			if status, ok := outcome["Status"].(string); ok && status == "Confirmed" {
				break
			}
		}
		time.Sleep(2 * time.Second)
	}

	if err != nil {
		t.Fatalf("acc.GetTransactionOutcome() failed: %v", err)
	}

	if status, _ := outcome["Status"].(string); status != "Confirmed" {
		t.Errorf("Expected transaction status to be 'Confirmed', but got '%s'", status)
	}
}

func TestE2EHelloWorldCertification(t *testing.T) {
	if privateKeyHex == "" || address == "" {
		t.Skip("Skipping E2E test: CIRCULAR_PRIVATE_KEY and CIRCULAR_ADDRESS environment variables must be set")
	}

	acc := cep.NewCEPAccount("testnet", "1.0")

	err := acc.Open(address)
	if err != nil {
		t.Fatalf("acc.Open() failed: %v", err)
	}

	err = acc.SetNetwork("testnet")
	if err != nil {
		t.Fatalf("acc.SetNetwork() failed: %v", err)
	}

	_, err = acc.UpdateAccount()
	if err != nil {
		t.Fatalf("acc.UpdateAccount() failed: %v", err)
	}

	resp, err := acc.SubmitCertificate("Hello World", privateKeyHex)
	if err != nil {
		t.Fatalf("acc.SubmitCertificate() failed: %v", err)
	}

	txHash, ok := resp["txHash"].(string)
	if !ok {
		t.Fatal("txHash not found in response")
	}

	// Poll for transaction outcome
	var outcome map[string]interface{}
	for i := 0; i < 10; i++ {
		outcome, err = acc.GetTransactionOutcome(txHash, 10)
		if err == nil && outcome != nil {
			if status, ok := outcome["Status"].(string); ok && status == "Confirmed" {
				break
			}
		}
		time.Sleep(2 * time.Second)
	}

	if err != nil {
		t.Fatalf("acc.GetTransactionOutcome() failed: %v", err)
	}

	if status, _ := outcome["Status"].(string); status != "Confirmed" {
		t.Errorf("Expected transaction status to be 'Confirmed', but got '%s'", status)
	}
}
</file>

<file path="AUDIT_FINDINGS.md">
# Go-lang vs. Node.js Implementation Audit Findings

This document outlines the differences in logic and dependencies between the Go-lang and Node.js implementations of the Circular Enterprise Protocol (CEP) APIs.

### 1.5 `hexToString` (Node.js) vs. `HexToString` (Go)

*   **Node.js (`reference-nodejs-implementation.js`):**
    ```javascript
    function hexToString(hex) {
        var str = '';
        hex = HexFix(hex);
        for (var i = 0; i < hex.length; i += 2) {
            var code = parseInt(hex.substr(i, 2), 16);
            if (!isNaN(code) && code !== 0) {
                str += String.fromCharCode(code);
            }
        }
        return str;
    }
    ```
    *   **Dependencies:** `HexFix` (local helper function).

*   **Go (`internal/utils/utils.go`):**
    ```go
    func HexToString(hexStr string) string {
        cleanedHex := HexFix(hexStr)
        bytes, err := hex.DecodeString(cleanedHex)
        if err != nil {
            return ""
        }
        // Strip null bytes to match the reference implementation
        return strings.ReplaceAll(string(bytes), "\x00", "")
    }
    ```
    *   **Dependencies:** `encoding/hex` package, `strings` package, `HexFix` (local helper function).

*   **Logic Difference:** Both convert a hexadecimal string back to its original string form. The Node.js version manually parses the hex string, while the Go version uses `hex.DecodeString`. The Go version also explicitly strips null bytes (`\x00`) to match the behavior of the Node.js implementation, which implicitly handles them due to `String.fromCharCode` behavior with `0`.

## 2. Certificate Class

### 2.1 `C_CERTIFICATE` (Node.js) vs. `Certificate` (Go) Structure

*   **Node.js (`reference-nodejs-implementation.js`):**
    ```javascript
    export class C_CERTIFICATE {
      
        constructor() {
            this.data = null;
            this.previousTxID = null;
            this.previousBlock = null;
        }
    ...
    }
    ```
    *   **Dependencies:** None.

*   **Go (`pkg/certificate/certificate.go`):**
    ```go
    type Certificate struct {
        Data          string `json:"data"`
        PreviousTxID  string `json:"previousTxID"`
        PreviousBlock string `json:"previousBlock"`
        Version       string `json:"version"`
    }
    ```
    *   **Dependencies:** None.

*   **Logic Difference:** The Go `Certificate` struct includes a `Version` field, which is not explicitly present as a field in the Node.js `C_CERTIFICATE` class constructor. However, the Node.js `getJSONCertificate` and `getCertificateSize` methods *do* include a `version` field in the JSON output, which is taken from `this.codeVersion` (a global `LIB_VERSION`). This indicates a slight structural difference in how the version is managed, but the serialized output is intended to be similar.

### 2.2 `setData` (Node.js) vs. `SetData` (Go)

*   **Node.js (`reference-nodejs-implementation.js`):**
    ```javascript
    setData(data)
    {
         this.data = stringToHex(data);    
    }
    ```
    *   **Dependencies:** `stringToHex` (local helper function).

*   **Go (`pkg/certificate/certificate.go`):**
    ```go
    func (c *Certificate) SetData(data string) {
        c.Data = hex.EncodeToString([]byte(data))
    }
    ```
    *   **Dependencies:** `encoding/hex` package.

*   **Logic Difference:** Functionally identical. Both convert the input string `data` to its hexadecimal representation and store it in the `data` field of the certificate. The Node.js version uses its local `stringToHex` helper, while the Go version directly uses `hex.EncodeToString`.

### 2.5 `getCertificateSize` (Node.js) vs. `GetCertificateSize` (Go)

*   **Node.js (`reference-nodejs-implementation.js`):**
    ```javascript
    getCertificateSize() {
        let certificate = {
            "data": data,
            "previousTxID": this.previousTxID,
            "previousBlock": this.previousBlock,
            "version": this.codeVersion
        };
        const jsonString = JSON.stringify(certificate);
        return Buffer.byteLength(jsonString, 'utf8');
    }
    ```
    *   **Dependencies:** `JSON.stringify` (built-in), `Buffer.byteLength` (Node.js Buffer API).

*   **Go (`pkg/certificate/certificate.go`):**
    ```go
    func (c *Certificate) GetCertificateSize() (int, error) {
        // The json.Marshal function converts the struct into a JSON byte slice.
        jsonBytes, err := json.Marshal(c)
        if err != nil {
            // Using fmt.Errorf to wrap the original error with more context.
            return 0, fmt.Errorf("failed to marshal certificate to JSON: %w", err)
        }
        // The length of the byte slice is the size of the certificate in bytes.
        return len(jsonBytes), nil
    }
    ```
    *   **Dependencies:** `encoding/json` package, `fmt` package.

*   **Logic Difference:** Both calculate the size of the JSON-serialized certificate in bytes. Similar to `getJSONCertificate`, the Node.js version manually constructs the object and uses `Buffer.byteLength`, while the Go version uses `json.Marshal` and then `len()` on the resulting byte slice. The Node.js version again uses an undefined `data` variable, which is a bug. The Go version correctly uses `c.Data`.

## 3. Account Class

### 3.1 `CEP_Account` (Node.js) vs. `CEPAccount` (Go) Structure and Constructor

*   **Node.js (`reference-nodejs-implementation.js`):**
    ```javascript
    export class CEP_Account {

        constructor() {
            this.address = null;
            this.publicKey = null;
            this.info = null;
            this.codeVersion = LIB_VERSION;
            this.lastError='';
            this.NAG_URL = DEFAULT_NAG;
            this.NETWORK_NODE = '';
            this.blockchain = DEFAULT_CHAIN;
            this.LatestTxID = '';
            this.Nonce = 0;
            this.data = {};
            this.intervalSec = 2;
        }
    ...
    }
    ```
    *   **Dependencies:** `LIB_VERSION`, `DEFAULT_NAG`, `DEFAULT_CHAIN` (global constants).

*   **Go (`pkg/account/account.go`):**
    ```go
    type CEPAccount struct {
        Address     string
        PublicKey   string
        Info        interface{}
        CodeVersion string
        LastError   string
        NAGURL      string
        NetworkNode string
        Blockchain  string
        LatestTxID  string
        Nonce       int
        Data        map[string]interface{}
        IntervalSec int
        NetworkURL  string
        PrivateKey  *secp256k1.PrivateKey
    }

    func NewCEPAccount() *CEPAccount {
        return &CEPAccount{
            CodeVersion: "1.0.13",
            NAGURL:      "https://nag.circularlabs.io/NAG.php?cep=",
            Blockchain:  "0x8a20baa40c45dc5055aeb26197c203e576ef389d9acb171bd62da11dc5ad72b2",
            Nonce:       0,
            Data:        make(map[string]interface{}),
            IntervalSec: 2,
        }
    }
    ```
    *   **Dependencies:** `secp256k1` (for `PrivateKey` type).

*   **Logic Difference:** Both define the structure and initialize default values for an account. The Go version uses a `NewCEPAccount` factory function for initialization, which is idiomatic Go. The Go `CEPAccount` struct also includes a `NetworkURL` field and a `PrivateKey` field, which are not directly present in the Node.js `CEP_Account` constructor's initial assignments, though `PrivateKey` is used in `signData` in Node.js. The `CodeVersion`, `NAGURL`, `Blockchain` are hardcoded in the Go `NewCEPAccount` function, while in Node.js they refer to global constants.

### 3.3 `updateAccount` (Node.js) vs. `UpdateAccount` (Go)

*   **Node.js (`reference-nodejs-implementation.js`):**
    ```javascript
    async updateAccount() {
        if (!this.address) {
            throw new Error("Account is not open");
        }

        let data = {
            "Blockchain": HexFix(this.blockchain),
            "Address": HexFix(this.address),
            "Version": this.codeVersion
        };

        try {
            const response = await fetch(this.NAG_URL + 'Circular_GetWalletNonce_' + this.NETWORK_NODE, {
                method: 'POST',
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(data),
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const jsonResponse = await response.json();

            if (jsonResponse.Result === 200 && jsonResponse.Response && jsonResponse.Response.Nonce !== undefined) {
                this.Nonce = jsonResponse.Response.Nonce + 1;
                return true;
            } else {
                throw new Error('Invalid response format or missing Nonce field');
            }
        } catch (error) {
            console.error('Error:', error);
            return false;
        }
    }
    ```
    *   **Dependencies:** `HexFix` (local helper function), `fetch` (Node.js built-in/global), `JSON.stringify` (built-in).

*   **Go (`pkg/account/account.go`):**
    ```go
    func (a *CEPAccount) UpdateAccount() (bool, error) {
        if a.Address == "" {
            return false, errors.New("Account is not open")
        }

        // Prepare the request payload
        requestData := struct {
            Blockchain string `json:"Blockchain"`
            Address    string `json:"Address"`
            Version    string `json:"Version"`
        }{
            Blockchain: utils.HexFix(a.Blockchain),
            Address:    utils.HexFix(a.Address),
            Version:    a.CodeVersion,
        }

        jsonData, err := json.Marshal(requestData)
        if err != nil {
            return false, fmt.Errorf("failed to marshal request data: %w", err)
        }

        // Construct the full URL for the API endpoint
        url := a.NAGURL + "Circular_GetWalletNonce_" + a.NetworkNode

        // Make the HTTP POST request
        resp, err := http.Post(url, "application/json", bytes.NewBuffer(jsonData))
        if err != nil {
            return false, fmt.Errorf("http post request failed: %w", err)
        }
        defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK {
            return false, fmt.Errorf("network request failed with status: %s", resp.Status)
        }

        // Decode the JSON response
        var responseData struct {
            Result   int `json:"Result"`
            Response struct {
                Nonce int `json:"Nonce"`
            } `json:"Response"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&responseData); err != nil {
            return false, fmt.Errorf("failed to decode response body: %w", err)
        }

        // Check for a successful result and update the nonce
        if responseData.Result == 200 {
            a.Nonce = responseData.Response.Nonce + 1
            return true, nil
        }

        return false, errors.New("failed to update account, invalid response from server")
    }
    ```
    *   **Dependencies:** `errors` package, `encoding/json` package, `bytes` package, `net/http` package, `fmt` package, `utils.HexFix` (internal utility).

*   **Logic Difference:** Both methods update the account's nonce by making a POST request to the NAG. The Node.js version uses `fetch` and `JSON.stringify`, while the Go version uses `net/http` and `json.Marshal`/`json.NewDecoder`. Error handling is done via `try-catch` in Node.js and `error` returns in Go. The Go version explicitly defines the structure of the request and response JSON, while Node.js relies on dynamic object creation.

### 3.10 `GetTransactionOutcome` (Node.js) vs. `GetTransactionOutcome` (Go)

*   **Node.js (`reference-nodejs-implementation.js`):**
    ```javascript
    async GetTransactionOutcome(TxID, timeoutSec) {
        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            const interval = this.intervalSec * 1000;  // Convert seconds to milliseconds
            const timeout = timeoutSec * 1000;    // Convert seconds to milliseconds

            const checkTransaction = () => {
                const elapsedTime = Date.now() - startTime;
                
                console.log('Checking transaction...', { elapsedTime, timeout });

                if (elapsedTime > timeout) {
                    console.log('Timeout exceeded');
                    reject(new Error('Timeout exceeded'));
                    return;
                }

                this.getTransactionbyID(TxID, 0, 10).then(data => {
                        console.log('Data received:', data);
                        if (data.Result === 200 && data.Response !== 'Transaction Not Found' && data.Response.Status!=='Pending') {
                            resolve(data.Response);  // Resolve if transaction is found and not 'Transaction Not Found'
                        } else {
                            console.log('Transaction not yet confirmed or not found, polling again...');
                            setTimeout(checkTransaction, interval);  // Continue polling
                        }
                    })
                    .catch(error => {
                        console.log('Error fetching transaction:', error);
                        reject(error);  // Reject on error
                    });
            };

            setTimeout(checkTransaction, interval);  // Start polling
        });
    }
    ```
    *   **Dependencies:** `Promise` (built-in), `Date.now` (built-in), `setTimeout` (built-in), `this.intervalSec` (instance property), `this.getTransactionbyID` (local method).

*   **Go (`pkg/account/account.go`):**
    ```go
    func (a *CEPAccount) GetTransactionOutcome(transactionID string) (map[string]interface{}, error) {
        // The Network Access Gateway URL must be set to know which network to query.
        if a.NAGURL == "" {
            return nil, fmt.Errorf("network is not set. Please call SetNetwork() first")
        }

        // Construct the full API endpoint URL for fetching the transaction outcome.
        requestURL := fmt.Sprintf("%s/transaction/outcome/%s", a.NAGURL, transactionID)

        // Perform an HTTP GET request to the specified endpoint.
        resp, err := http.Get(requestURL)
        if err != nil {
            return nil, fmt.Errorf("failed to send get transaction outcome request: %w", err)
        }
        defer resp.Body.Close()

        // Check for a successful HTTP response. A non-200 status indicates a problem.
        if resp.StatusCode != http.StatusOK {
            return nil, fmt.Errorf("network returned an error: %s", resp.Status)
        }

        // Read the entire body of the HTTP response.
        body, err := io.ReadAll(resp.Body)
        if err != nil {
            return nil, fmt.Errorf("failed to read response body: %w", err)
        }

        // Unmarshal the JSON response into a map. Using a map allows for flexible handling
        // of various outcome structures returned by the network.
        var outcomeDetails map[string]interface{}
        if err := json.Unmarshal(body, &outcomeDetails); err != nil {
            return nil, fmt.Errorf("failed to decode transaction outcome: %w", err)
        }

        return outcomeDetails, nil
    }
    ```
    *   **Dependencies:** `fmt` package, `net/http` package, `io` package, `encoding/json` package.

*   **Logic Difference:** This is another significant difference. The Node.js `GetTransactionOutcome` implements a polling mechanism with a timeout, repeatedly calling `getTransactionbyID` until the transaction is found and its status is not 'Pending' or a timeout occurs. The Go `GetTransactionOutcome` method, however, makes a single HTTP GET request to a dedicated `/transaction/outcome/{id}` endpoint. This implies that the Go implementation relies on the server-side to handle the polling or provide immediate transaction outcome, whereas the Node.js version handles the polling client-side. The Go version is simpler as it expects the outcome to be available directly from the endpoint.

## 4. CEP Class

### 4.4 `GetNAG` (Node.js) vs. `GetNAG` (Go)

*   **Node.js (`reference-nodejs-implementation.js`):**
    ```javascript
    async GetNAG(network) {
        try {
            const response = await fetch(NETWORK_URL + network);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.text();
            return data;
        } catch (error) {
            console.error("Error fetching NAG:", error);
            throw error;
        }
    }
    ```
    *   **Dependencies:** `NETWORK_URL` (global constant), `fetch` (Node.js built-in/global).

*   **Go (`pkg/circular_enterprise_apis.go`):**
    ```go
    func GetNAG(network string) (string, error) {
        resp, err := http.Get(NetworkURL + network)
        if err != nil {
            return "", err
        }
        defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil {
            return "", err
        }

        return string(body), nil
    }
    ```
    *   **Dependencies:** `net/http` package, `io` package, `NetworkURL` (global constant).

*   **Logic Difference:** Both methods fetch the NAG URL for a given network. The Node.js version uses `fetch` and handles errors with `try-catch`. The Go version uses `net/http.Get` and returns an error. Both append the network to a global `NETWORK_URL` constant. The Node.js version is an instance method, while the Go version is a standalone function.
</file>

<file path="e2e_testing_plan.md">
# E2E Testing Plan

End-to-End (E2E) tests are designed to be run against a live, deployed infrastructure (like a testnet or staging environment). This is a crucial step to ensure your code works in a real-world scenario.

### Where to Put the Logic

The ideal place for these tests is already set up in your project structure: the **`tests/e2e/`** directory.

We would create a new file, for example: `tests/e2e/live_infra_test.go`.

This separation is important because:
1.  **Speed:** E2E tests are much slower than unit or integration tests because they involve real network latency.
2.  **Environment Dependency:** They require a live environment to be running and properly configured.
3.  **Cost/State:** They can potentially cost money (if using a paid service) and change the state of the blockchain or application you're testing against.

### How to Start Testing It

Here is the plan to implement and run these E2E tests:

1.  **Configuration:** We'll need to configure the tests to point to the live infrastructure. This is done securely using environment variables, just like the integration test. We would add new variables to your `.env` file (or a new `.env.e2e` file) for the live testnet URL and any required credentials.
    *   `E2E_NAG_URL="https://<your-live-testnet-nag-url>"`
    *   `E2E_PRIVATE_KEY="..."`
    *   `E2E_ADDRESS="..."`

2.  **Create the E2E Test File:** I will create `tests/e2e/live_infra_test.go`. This file will be very similar to the integration test, but instead of creating a mock server, it will connect to the `E2E_NAG_URL`.

3.  **Use Go Build Tags:** To prevent these slow E2E tests from running every time you execute `go test ./...`, we'll use a Go build tag. We'll add this comment at the top of the E2E test file:
    ```go
    //go:build e2e
    ```
    This tells the Go compiler to only include this file in the build if you explicitly ask for the `e2e` tag.

4.  **Running the E2E Tests:** You would then run these specific tests with a special command:
    ```bash
    go test -v -tags=e2e ./tests/e2e/...
    ```

This approach gives you a robust testing strategy: fast unit tests for local development, slightly slower integration tests for checking component interactions, and separate, deliberate E2E tests to validate against a live system.
</file>

<file path="go_nodejs_alignment_plan.md">
# Go/Node.js API Alignment Plan

This plan outlines the steps to align the Go implementation with the Node.js reference, prioritizing Go idiomatic style and ensuring test conformance.

## Goal:
- Align Go developer experience with Node.js.
- Maintain idiomatic Go API.
- Ensure tests conform to aligned API.

## Progress Tracking:
- **Rule:** A checkbox should not be checked until all nested checkboxes under it are verified and checked.
- [ ] Top-level task
  - [ ] Sub-task

---

## 1. Helper Functions Alignment [x]

- [x] **Timestamp Format Consistency:**
  - [x] Align `GetFormattedTimestamp()` in `pkg/circular_enterprise_apis.go` to return `YYYY:MM:DD-HH:MM:SS` format, consistent with `internal/utils/utils.go` and Node.js.

## 2. Certificate Structure and Operations Alignment [x]

- [x] **Data Encoding in `Certificate.SetData`:**
  - [x] Modify `Certificate.SetData` in `pkg/circular_enterprise_apis.go` to automatically hex-encode the input `data` before storing it, mirroring Node.js behavior.
  - [ ] **Note:** `NewCertificate` and `GetJSONCertificate`/`GetCertificateSize` are already idiomatic Go and will remain as is.

## 3. Account Structure and Operations Alignment [x]

- [x] **Private Key Handling and `SignData`:**
  - [x] Modify `CEPAccount.SignData` in `pkg/account.go` to accept the private key as an argument (`privateKey string`), similar to Node.js.
  - [x] Remove `PrivateKey` field from `CEPAccount` struct if it's no longer needed for signing operations, or clarify its purpose if it remains.
- [x] **`SubmitCertificate` API Alignment:**
  - [x] Modify `CEPAccount.SubmitCertificate` in `pkg/account.go` to accept raw `pdata` (string) and `privateKey` (string) as arguments, similar to Node.js.
  - [x] Implement internal logic within `SubmitCertificate` to:
    - [x] Create the `PayloadObject` and `Payload` (hex-encoded JSON string).
    - [x] Generate `Timestamp` using the consistent format.
    - [x] Construct the `str` for hashing.
    - [x] Generate `ID` using SHA-256.
    - [x] Call `SignData` (with the new signature) to get the `Signature`.
    - [x] Construct the final `data` payload for the HTTP request.
- [x] **`UpdateAccount` API Endpoint Alignment:**
  - [x] Modify `CEPAccount.UpdateAccount` in `pkg/account.go` to append `a.NetworkNode` to the `NAGURL` when calling `Circular_GetWalletNonce_` (or its Go equivalent), if `NetworkNode` is a required part of the endpoint.
- [x] **Transaction Query Endpoints Alignment:**
  - [x] Review Node.js `getTransaction` and `getTransactionbyID` methods and their corresponding API calls (`Circular_GetTransactionbyID_`).
  - [x] Ensure Go's `CEPAccount.GetTransaction` and `CEPAccount.GetTransactionByID` methods correctly map to the expected backend API endpoints and parameter formats, potentially consolidating or adjusting them to match `Circular_GetTransactionbyID_` if it's the primary endpoint for transaction queries.
    - [x] Specifically, ensure Go can query by `TxID`, `Start` block, and `End` block if the Node.js implementation supports this.

## 4. API Endpoints and Communication Alignment [x]

- [x] **Consistent Endpoint Naming:**
  - [x] Modify Go HTTP requests to use the exact endpoint names (e.g., `Circular_GetWalletNonce_`, `Circular_AddTransaction_`, `Circular_GetTransactionbyID_`) if the backend expects these specific names. This might involve changing the `fmt.Sprintf` calls in `pkg/account.go`.

## 5. Test Conformance [x]

- [x] **Update Existing Tests:**
  - [x] Modify `pkg/account_test.go` and `tests/integration/circular_enterprise_apis_integration_test.go` to reflect the changes made to the `CEPAccount` and `Certificate` APIs.
- [x] **Add New Tests (if necessary):**
  - [x] Create new unit or integration tests to cover any new functionality or edge cases introduced by the alignment.
  - [x] Ensure tests cover the new `SubmitCertificate` signature and behavior.
  - [x] Verify transaction query methods work as expected after alignment.

---

## General Notes:
- Go's idiomatic error handling (`error` return values) will be maintained.
- Go's idiomatic struct usage and factory functions (`NewCEPAccount`, `NewCertificate`) will be maintained.
- Cryptographic primitives (SHA-256, secp256k1 ECDSA) are consistent and require no changes.
</file>

<file path="new_audit_findings.md">
# Go Library Alignment Plan

This document outlines the step-by-step plan to align the Go-lang library with the reference Java and Node.js implementations. Each step will be a separate commit with a descriptive message following the `fix/[logic-to-be-fixed]` convention.

## Step 1: Foundational Utilities (`internal/utils`)

*   **Branch:** `fix/utils-alignment`
*   **Objective:** Ensure the utility functions in `internal/utils/utils.go` are consistent with the helper functions in the reference implementations. This is a low-risk starting point as these functions have no dependencies within the Go library itself.
*   **Tasks:**
    1.  **`PadNumber`:** Verify that the logic is identical to the `padNumber` function in the Node.js implementation.
    2.  **`GetFormattedTimestamp`:** The current implementation is correct.
    3.  **`HexFix`:** The current implementation is correct.
    4.  **`StringToHex` and `HexToString`:** The current implementation is correct.

## Step 2: Certificate Handling (`pkg/certificate`)

*   **Branch:** `fix/certificate-logic`
*   **Objective:** Align the `Certificate` struct and its methods with the `C_CERTIFICATE` class in the Node.js implementation and the implicit certificate handling in the Java implementation.
*   **Tasks:**
    1.  **`NewCertificate`:** The current implementation is correct.
    2.  **`SetData` and `GetData`:** The current implementation is correct.
    3.  **`GetJSONCertificate` and `GetCertificateSize`:** The current implementation is correct.

## Step 3: Core Account Functionality (`pkg/account`)

*   **Branch:** `fix/account-core`
*   **Objective:** Align the core, non-network-dependent functionality of the `CEPAccount` struct.
*   **Tasks:**
    1.  **`NewCEPAccount`:** The current implementation is correct.
    2.  **`Open`:** The current implementation is correct.
    3.  **`Close`:** The current implementation is correct.

## Step 4: Network and Blockchain Interaction (`pkg/account`)

*   **Branch:** `fix/account-network`
*   **Objective:** Align the methods responsible for interacting with the blockchain network.
*   **Tasks:**
    1.  **`SetNetwork`:** The current implementation is correct.
    2.  **`UpdateAccount`:** The current implementation is correct.
    3.  **`GetTransaction` and `GetTransactionByID`:** The current implementation is correct.
    4.  **`GetTransactionOutcome`:** The current implementation is correct.

## Step 5: Cryptographic Signing (`pkg/account`)

*   **Branch:** `fix/account-signing`
*   **Objective:** Align the `SignData` method with the reference implementations. This is a critical and complex piece of logic that depends on the rest of the account functionality being correct.
*   **Tasks:**
    1.  **`SignData`:** The current implementation uses `decred/dcrd` for deterministic signing, which is a suitable replacement for the `elliptic` and `BouncyCastle` libraries used in the reference implementations. The key is to ensure the data being signed is hashed in the same way (SHA-256) and that the signature is DER-encoded.

## Step 6: Certificate Submission (`pkg/account`)

*   **Branch:** `fix/certificate-submission`
*   **Objective:** Align the `SubmitCertificate` method. This is the final step, bringing together all the other components.
*   **Tasks:**
    1.  **`SubmitCertificate`:** The current implementation is correct.

## Step 7: Top-Level API (`pkg`)

*   **Branch:** `fix/toplevel-api`
*   **Objective:** Ensure the main entry points of the library are consistent with the reference implementations.
*   **Tasks:**
    1.  **`NewCEP`:** The current implementation is correct.
    2.  **`NewAccount`:** The current implementation is correct.
    3.  **`NewCertificate`:** The current implementation is correct.
    4.  **`GetNAG`:** The current implementation is correct.
</file>

<file path="nodejs_go_audit_findings.md">
# Node.js vs. Go Implementation Audit Findings

This document outlines the differences identified between the Node.js reference implementation (`reference-nodejs-implementation.js`) and the Go implementation (`pkg/account.go`, `pkg/circular_enterprise_apis.go`, `internal/utils/utils.go`).

## Summary of Key Differences

## 1. Helper Functions

### Node.js Helper Functions:
- `padNumber(num)`: Adds a leading zero to numbers less than 10.
- `getFormattedTimestamp()`: Returns a UTC timestamp in `YYYY:MM:DD-HH:MM:SS` format.
- `HexFix(word)`: Removes '0x' prefix from hexadecimal strings.
- `stringToHex(str)`: Converts a string to its hexadecimal representation.
- `hexToString(hex)`: Converts a hexadecimal string back to its original string form.

### Go Helper Functions (`internal/utils/utils.go`):
- `PadNumber(num int)`: Equivalent to Node.js `padNumber`.
- `GetFormattedTimestamp()`: Equivalent to Node.js `getFormattedTimestamp`.
- `HexFix(word string)`: Equivalent to Node.js `HexFix`.
- `StringToHex(str string)`: Equivalent to Node.js `stringToHex`.
- `HexToString(hexStr string)`: Equivalent to Node.js `hexToString`.

### Differences/Notes:
- The Go implementation of `HexToString` explicitly handles stripping null bytes (`\x00`) to match the behavior of the Node.js version, which implicitly handles this due to JavaScript's string handling.
- The Go `GetFormattedTimestamp` uses `time.Now().UTC()` and `fmt.Sprintf` to format the timestamp, while the Node.js version uses `Date` object methods. Both achieve the same `YYYY:MM:DD-HH:MM:SS` format.
- The Go `GetFormattedTimestamp` in `circular_enterprise_apis.go` returns a Unix timestamp as a string, which is different from the `YYYY:MM:DD-HH:MM:SS` format in `internal/utils/utils.go` and the Node.js implementation. This needs to be aligned.

## 2. Certificate Structure and Operations

### Node.js (`C_CERTIFICATE` class):
- `data`: Stores the certificate data (hex-encoded).
- `previousTxID`: Stores the previous transaction ID.
- `previousBlock`: Stores the previous block.
- `version`: Stores the code version.
- `setData(data)`: Sets the certificate data, converting it to hex.
- `getData()`: Retrieves the certificate data, converting it from hex.
- `getJSONCertificate()`: Returns the certificate as a JSON string.
- `getCertificateSize()`: Calculates the size of the certificate in bytes.

### Go (`Certificate` struct in `pkg/circular_enterprise_apis.go`):
- `Data`: Stores the certificate data (string).
- `PreviousTxID`: Stores the previous transaction ID.
- `PreviousBlock`: Stores the previous block.
- `Version`: Stores the version.
- `SetData(data string)`: Sets the certificate data.
- `GetData()`: Retrieves the certificate data.
- `GetJSONCertificate()`: Returns the certificate as a JSON string.
- `GetCertificateSize()`: Calculates the size of the certificate in bytes.

### Differences/Notes:
- **Data Encoding:** In Node.js, `setData` automatically converts the input `data` to hex, and `getData` converts it back. In Go, the `Data` field is a `string`, and the `SetData` and `GetData` methods do not perform hex encoding/decoding. This means the Go implementation expects the `data` to be already hex-encoded when `SetData` is called, or it will store raw string data. This is a significant difference that needs to be addressed for compatibility.
- **Constructor:** Node.js uses a constructor for `C_CERTIFICATE`. Go uses `NewCertificate` factory function.
- **`codeVersion` vs `LibVersion`:** Node.js uses `this.codeVersion` which is initialized from `LIB_VERSION`. Go uses `LibVersion` constant directly.

## 3. Account Structure and Operations

### Node.js (`CEP_Account` class):
- **Properties:** `address`, `publicKey`, `info`, `codeVersion`, `lastError`, `NAG_URL`, `NETWORK_NODE`, `blockchain`, `LatestTxID`, `Nonce`, `data`, `intervalSec`.
- `constructor()`: Initializes properties with default values.
- `open(address)`: Sets the account address.
- `updateAccount()`: Fetches account nonce from the NAG.
- `setNetwork(network)`: Fetches the NAG URL for a given network.
- `setBlockchain(chain)`: Sets the blockchain address.
- `close()`: Clears account data.
- `signData(data, privateKey)`: Signs data using `secp256k1` and `sha256`.
- `getTransaction(blockNum, txID)`: Searches for a transaction by ID and block number.
- `getTransactionbyID(TxID, Start, End)`: Searches for a transaction by ID within a block range.
- `submitCertificate(pdata, privateKey)`: Submits a certificate to the blockchain.
- `GetTransactionOutcome(TxID, timeoutSec)`: Polls for transaction outcome.

### Go (`CEPAccount` struct in `pkg/account.go`):
- **Properties:** `Address`, `PublicKey`, `Info`, `CodeVersion`, `LastError`, `NAGURL`, `NetworkNode`, `Blockchain`, `LatestTxID`, `Nonce`, `Data`, `IntervalSec`, `NetworkURL`, `PrivateKey`.
- `NewCEPAccount()`: Factory function to create and initialize `CEPAccount`.
- `Open(address string)`: Equivalent to Node.js `open`.
- `UpdateAccount()`: Equivalent to Node.js `updateAccount`.
- `SetNetwork(network string)`: Equivalent to Node.js `setNetwork`.
- `Close()`: Equivalent to Node.js `close`.
- `SignData(dataToSign []byte)`: Signs data using `sha256` and `decdsa.Sign`.
- `GetTransaction(transactionHash string)`: Retrieves transaction details by hash.
- `GetTransactionByID(transactionID string)`: Retrieves transaction details by ID.
- `SubmitCertificate(cert *Certificate)`: Submits a certificate.
- `GetTransactionOutcome(TxID string, timeoutSec int)`: Polls for transaction outcome.

### Differences/Notes:
- **Private Key Handling:** The Go `CEPAccount` struct has a `PrivateKey` field of type `*secp256k1.PrivateKey`, allowing it to hold the private key directly. The Node.js `CEP_Account` class does not store the private key; it's passed as an argument to `signData` and `submitCertificate`.
- **`SignData` Parameters:** In Node.js, `signData` takes `data` and `privateKey` as arguments. In Go, `SignData` takes `dataToSign []byte` and uses the `a.PrivateKey` field. This implies the private key needs to be set on the `CEPAccount` struct in Go before calling `SignData`.
- **`SubmitCertificate` Parameters:** In Node.js, `submitCertificate` takes `pdata` (payload data) and `privateKey`. In Go, `SubmitCertificate` takes a `*Certificate` object. The signing of the payload is handled internally within `submitCertificate` in Node.js, while in Go, the `Certificate` object is expected to be prepared (and potentially signed) before being passed to `SubmitCertificate`.
- **`GetTransaction` and `GetTransactionByID`:** The Node.js implementation has two `getTransaction` methods (one with `blockNum, txID` and another with `BlockID, TxID`) and `getTransactionbyID`. The Go implementation has `GetTransaction` (by hash) and `GetTransactionByID` (by ID). The Node.js `getTransaction` methods seem to combine block and transaction ID, while Go separates them. This needs careful review for functional equivalence.
- **Error Handling:** Go uses `error` return values for explicit error handling, while Node.js uses `try-catch` blocks and returns `false` or throws errors.
- **Network URL Initialization:** In Go, `NetworkURL` is initialized in `NewCEPAccount` from a constant. In Node.js, `NETWORK_URL` is a global constant.
- **`UpdateAccount` API Endpoint:** The Node.js `updateAccount` calls `Circular_GetWalletNonce_` endpoint. The Go `UpdateAccount` calls `GetWalletNonce` endpoint. The Node.js version appends `this.NETWORK_NODE` to the endpoint, which is not present in the Go version. This needs to be aligned.
- **`GetTransactionOutcome`:** The Node.js version uses `Promise` and `setTimeout` for polling, while the Go version uses a `for` loop with `time.Sleep`.

## 4. Cryptography and Hashing

### Node.js:
- **Hashing:** Uses `sha256` library for SHA-256 hashing.
- **Signing:** Uses `elliptic` library (`secp256k1` curve) for ECDSA signing.

### Go:
- **Hashing:** Uses `crypto/sha256` package for SHA-256 hashing.
- **Signing:** Uses `github.com/decred/dcrd/dcrec/secp256k1/v4/ecdsa` for ECDSA signing.

### Differences/Notes:
- Both implementations use SHA-256 for hashing and `secp256k1` for ECDSA signing. The underlying cryptographic primitives are consistent.
- The Go implementation uses `decdsa.Sign` which returns a raw byte slice, then `hex.EncodeToString(signature.Serialize())` is used to get the DER-encoded hex string. This is consistent with the Node.js `key.sign(msgHash).toDER('hex')`.

## 5. API Endpoints and Communication

### Node.js:
- Uses `node-fetch` for HTTP requests.
- API endpoints are constructed by concatenating `NAG_URL` with specific method names (e.g., `Circular_GetWalletNonce_`, `Circular_AddTransaction_`, `Circular_GetTransactionbyID_`).
- Appends `NETWORK_NODE` to some API calls.

### Go:
- Uses `net/http` package for HTTP requests.
- API endpoints are constructed by concatenating `NAGURL` with specific method names or paths (e.g., `GetWalletNonce`, `/transaction/`).
- Does not explicitly append `NetworkNode` to API calls in the same way as Node.js.

### Differences/Notes:
- **Endpoint Naming:** The Node.js implementation uses `Circular_` prefixes and appends `_` to method names in the URL (e.g., `Circular_GetWalletNonce_`). The Go implementation uses simpler method names (e.g., `GetWalletNonce`). This needs to be aligned for consistent API calls.
- **`NETWORK_NODE`:** The Node.js implementation appends `this.NETWORK_NODE` to some API calls (e.g., `Circular_GetWalletNonce_` and `Circular_AddTransaction_`). The Go implementation does not have an equivalent appending of `NetworkNode` to the URL. This is a significant difference that needs to be investigated and potentially aligned for correct communication with the backend.
- **Transaction Query Endpoints:** Node.js has `Circular_GetTransactionbyID_` which takes `Start` and `End` parameters. Go has `GetTransaction` and `GetTransactionByID` which seem to map to different endpoint structures (`/transaction/{hash}` or `/transaction/{id}`). This needs to be carefully reviewed to ensure the Go implementation is hitting the correct endpoints with the correct parameters for transaction queries.
- **HTTP Client:** Node.js uses `node-fetch`, Go uses `net/http`. Both are standard for their respective environments.

## 6. Dependencies

### Node.js:
- `elliptic`: For ECDSA cryptography.
- `sha256`: For SHA-256 hashing.
- `node-fetch`: For making HTTP requests.

### Go:
- `github.com/decred/dcrd/dcrec/secp256k1/v4`: For `secp256k1` curve and ECDSA signing.
- Standard library `crypto/sha256`: For SHA-256 hashing.
- Standard library `net/http`: For making HTTP requests.
- Standard library `encoding/hex`, `encoding/json`, `fmt`, `io`, `strings`, `time`, `bytes`, `net/url`.

### Differences/Notes:
- Both implementations rely on external libraries for cryptography and HTTP communication, but the specific libraries differ due to language ecosystems. The core cryptographic algorithms (SHA-256, secp256k1 ECDSA) are consistent.

## 7. Coding Style and Conventions

### Node.js:
- Uses JavaScript class-based structure.
- CamelCase for function and variable names.
- `this` keyword for class properties.
- `async/await` for asynchronous operations.

### Go:
- Uses Go structs and methods.
- PascalCase for exported functions and struct fields, camelCase for unexported.
- Explicit error handling with `error` return values.
- Goroutines and channels for concurrency (though not heavily used in the provided snippets).

### Differences/Notes:
- Significant differences in language paradigms (object-oriented vs. procedural/struct-based).
- Error handling is a major difference, with Go's explicit error returns contrasting with Node.js's `try-catch` and promise-based error handling.
- Naming conventions are standard for each language.

---
</file>

<file path="recommendations-account_test.md">
Of course. After reviewing the provided Go test file, I've identified several areas with potential issues and opportunities for improvement. The tests are generally well-structured using table-driven tests and proper mocking, but some refinements could enhance their robustness and maintainability.

Here are the key issues found in the test file:

-----

### 1\. Inconsistent Error Handling and Verification

There are inconsistencies in how error messages are verified across different test functions.

  * **Exact vs. Substring Matching**: In `TestOpen`, errors are checked with an exact match (`err.Error() != tc.expectedError`). However, in `TestSetNetwork`, `TestSubmitCertificate`, and others, errors are checked using `strings.Contains()`.
  * **Inconsistent Production Code Errors**: The tests for `TestGetTransaction` and `TestGetTransactionByID` reveal that the underlying functions produce slightly different error messages for similar failures.
      * **HTTP Error in `GetTransaction`**: `network returned an error: 404 Not Found`
      * **HTTP Error in `GetTransactionByID`**: `network returned a non-200 status code: 404 Not Found`

**Recommendation:**
Adopt a consistent strategy for error verification. Using `strings.Contains()` is generally more robust, as it's less likely to break if an error message is slightly changed (e.g., punctuation or capitalization). The inconsistency in production error messages should also be addressed in the main library code to ensure uniformity.

-----

### 2\. Limited Coverage for Input Validation

The test for the `Open` function only validates against a single invalid case: an empty address string.

```go
func TestOpen(t *testing.T) {
    testCases := []struct {
        // ...
    }{
        // ...
        {
            name:          "Empty Address",
            address:       "",
            expectError:   true,
            expectedError: "Invalid address format",
        },
    }
    // ...
}
```

**Recommendation:**
Expand the test cases to cover other potential invalid address formats to ensure the validation logic is comprehensive. Examples include:

  * Addresses with incorrect prefixes (e.g., not starting with "0x").
  * Addresses with invalid hexadecimal characters.
  * Addresses with incorrect lengths.

-----

### 3\. Brittle Mocking of URLs

In `TestUpdateAccount`, the test constructs a specific URL for the mock server, including the path and query parameters. This makes the test dependent on the implementation details of how the URL is built in the `UpdateAccount` function.

```go
// from TestUpdateAccount
acc.NAGURL = server.URL + "/NAG.php?cep=" // Adjust to match the expected URL structure
acc.NetworkNode = "mock_node"             // This part of the URL is appended by UpdateAccount
```

**Recommendation:**
Decouple the test from the URL construction logic. The mock server should only care about handling requests to its base URL. The function being tested (`UpdateAccount`) should be responsible for appending the necessary path and parameters. The test should only set the base URL (`acc.NAGURL = server.URL`). This makes the test more resilient to changes in the URL structure.

-----

### 4\. Missing Tests for Malformed JSON Payloads

The tests effectively check for syntactically invalid JSON (e.g., a truncated string), but they don't test for responses that are syntactically valid but structurally incorrect. For example, a successful response might be missing a required field like `"Response"` or `"Nonce"`.

```go
// from TestUpdateAccount
{
    name:           "Invalid JSON Response",
    accountAddress: "0x123",
    // This Nonce is a string instead of an int, which causes a unmarshalling error.
    mockResponse:   `{"Result":200,"Response":{"Nonce":"invalid"}}`, 
    mockStatusCode: http.StatusOK,
    expectSuccess:  false,
    expectError:    true,
    expectedNonce:  0,
},
```

**Recommendation:**
Add test cases to simulate responses where the JSON is valid, but the payload is missing expected fields. This ensures the code can gracefully handle unexpected API responses without causing a runtime panic (e.g., from a nil pointer dereference).

-----

### 5\. Stylistic Concern: Dot Imports

The file uses dot imports (`.`) to import the `account` and `certificate` packages.

```go
import (
    // ...
    . "github.com/lessuselesss/CEP-Go-APIs/pkg/account"
    . "github.com/lessuselesss/CEP-Go-APIs/pkg/certificate"
)
```

While this can make test code less verbose, it can also harm readability by obscuring where symbols like `NewCEPAccount` and `Certificate` originate. This can become a maintenance issue in larger codebases.

**Recommendation:**
It is generally recommended to avoid dot imports. Using a standard import and qualifying symbols with the package name (e.g., `account.NewCEPAccount`) makes the code clearer and easier to navigate.
</file>

<file path="pkg/certificate_test.go">
package circular_enterprise_apis

import (
	"encoding/hex"
	"encoding/json"
	"reflect"
	"testing"
)

func TestSetData(t *testing.T) {
	testCases := []struct {
		name string
		data string
	}{
		{
			name: "Simple ASCII string",
			data: "hello world",
		},
		{
			name: "Empty string",
			data: "",
		},
		{
			name: "String with numbers and symbols",
			data: "123!@#$",
		},
		{
			name: "Unicode string",
			data: ", ",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			cert := &Certificate{}
			cert.SetData(tc.data)

			expectedHex := hex.EncodeToString([]byte(tc.data))

			if cert.Data != expectedHex {
				t.Errorf("Expected Data to be '%s', but got '%s'", expectedHex, cert.Data)
			}
		})
	}
}

func TestGetData(t *testing.T) {
	testCases := []struct {
		name         string
		cert         Certificate
		expectedData string
		expectError  bool
	}{
		{
			name: "Simple ASCII string",
			cert: Certificate{
				Data: hex.EncodeToString([]byte("hello world")),
			},
			expectedData: "hello world",
			expectError:  false,
		},
		{
			name: "Unicode string",
			cert: Certificate{
				Data: hex.EncodeToString([]byte(", ")),
			},
			expectedData: ", ",
			expectError:  false,
		},
		{
			name: "Empty string",
			cert: Certificate{
				Data: "",
			},
			expectedData: "",
			expectError:  false,
		},
		{
			name: "Invalid hex data",
			cert: Certificate{
				Data: "this is not hex",
			},
			expectedData: "",
			expectError:  true,
		},
		{
			name: "Odd length hex string",
			cert: Certificate{
				Data: "123",
			},
			expectedData: "",
			expectError:  true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			data, err := tc.cert.GetData()

			if tc.expectError {
				if err == nil {
					t.Errorf("Expected an error, but got none")
				}
			} else {
				if err != nil {
					t.Errorf("Did not expect an error, but got: %v", err)
				}
				if data != tc.expectedData {
					t.Errorf("Expected data to be '%s', but got '%s'", tc.expectedData, data)
				}
			}
		})
	}
}

func TestGetJSONCertificate(t *testing.T) {
	testCases := []struct {
		name         string
		cert         Certificate
		expectedJSON string
		expectError  bool
	}{
		{
			name: "Full certificate",
			cert: Certificate{
				Data:          hex.EncodeToString([]byte("hello world")),
				PreviousTxID:  "txid123",
				PreviousBlock: "block456",
				Version:       "1.0.0",
			},
			expectedJSON: `{"data":"68656c6c6f20776f726c64","previousTxID":"txid123","previousBlock":"block456","version":"1.0.0"}`,
			expectError:  false,
		},
		{
			name:         "Empty certificate",
			cert:         Certificate{},
			expectedJSON: `{"data":"","previousTxID":"","previousBlock":"","version":""}`,
			expectError:  false,
		},
		{
			name: "Certificate with some empty fields",
			cert: Certificate{
				Data:    hex.EncodeToString([]byte("some data")),
				Version: "1.1.0",
			},
			expectedJSON: `{"data":"736f6d652064617461","previousTxID":"","previousBlock":"","version":"1.1.0"}`,
			expectError:  false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			jsonString, err := tc.cert.GetJSONCertificate()

			if tc.expectError {
				if err == nil {
					t.Errorf("Expected an error, but got none")
				}
				return
			}

			if err != nil {
				t.Errorf("Did not expect an error, but got: %v", err)
			}

			var resultData, expectedData map[string]interface{}

			err = json.Unmarshal([]byte(jsonString), &resultData)
			if err != nil {
				t.Fatalf("Failed to unmarshal actual JSON string: %v", err)
			}

			err = json.Unmarshal([]byte(tc.expectedJSON), &expectedData)
			if err != nil {
				t.Fatalf("Failed to unmarshal expected JSON string: %v", err)
			}

			if !reflect.DeepEqual(resultData, expectedData) {
				t.Errorf("Expected JSON \n%s\n, but got \n%s", tc.expectedJSON, jsonString)
			}
		})
	}
}

func TestGetCertificateSize(t *testing.T) {
	testCases := []struct {
		name         string
		cert         Certificate
		expectedSize int
		expectError  bool
	}{
		{
			name: "Full certificate",
			cert: Certificate{
				Data:          hex.EncodeToString([]byte("hello world")),
				PreviousTxID:  "txid123",
				PreviousBlock: "block456",
				Version:       "1.0.0",
			},
			expectedSize: 103,
			expectError:  false,
		},
		{
			name:         "Empty certificate",
			cert:         Certificate{},
			expectedSize: 61,
			expectError:  false,
		},
		{
			name: "Certificate with unicode data",
			cert: Certificate{
				Data: hex.EncodeToString([]byte(", ")),
			},
			expectedSize: 89,
			expectError:  false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			size, err := tc.cert.GetCertificateSize()

			if tc.expectError {
				if err == nil {
					t.Errorf("Expected an error, but got none")
				}
				return
			}

			if err != nil {
				t.Errorf("Did not expect an error, but got: %v", err)
			}

			if size != tc.expectedSize {
				t.Errorf("Expected size to be %d, but got %d", tc.expectedSize, size)
			}
		})
	}
}
</file>

<file path="pkg/certificate.go">
package circular_enterprise_apis

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
)

// Certificate represents a CIRCULAR certificate.
type Certificate struct {
	Data          string `json:"data"`
	PreviousTxID  string `json:"previousTxID"`
	PreviousBlock string `json:"previousBlock"`
	Version       string `json:"version"`
}

// NewCertificate creates and initializes a new Certificate instance.
func NewCertificate(version string) *Certificate {
	return &Certificate{
		Version: version,
	}
}

// SetData inserts application data into the certificate after converting it to a hexadecimal string.
// The `data` parameter is the string data to be stored.
func (c *Certificate) SetData(data string) {
	c.Data = hex.EncodeToString([]byte(data))
}

// GetData decodes the hexadecimal data from the certificate into a string.
// It returns the decoded string and an error if the data is not a valid hexadecimal format.
func (c *Certificate) GetData() (string, error) {
	decodedData, err := hex.DecodeString(c.Data)
	if err != nil {
		return "", fmt.Errorf("failed to decode certificate data: %w", err)
	}
	return string(decodedData), nil
}

// GetJSONCertificate serializes the certificate into a JSON string.
// It returns the JSON string and an error if the serialization fails.
func (c *Certificate) GetJSONCertificate() (string, error) {
	// The json.Marshal function converts the struct into a JSON byte slice.
	jsonBytes, err := json.Marshal(c)
	if err != nil {
		// Using fmt.Errorf to wrap the original error with more context.
		return "", fmt.Errorf("failed to marshal certificate to JSON: %w", err)
	}
	// Convert the byte slice to a string for the return value.
	return string(jsonBytes), nil
}

// GetCertificateSize calculates the size of the JSON-serialized certificate in bytes.
// It returns the size and an error if the serialization fails.
func (c *Certificate) GetCertificateSize() (int, error) {
	// The json.Marshal function converts the struct into a JSON byte slice.
	jsonBytes, err := json.Marshal(c)
	if err != nil {
		// Using fmt.Errorf to wrap the original error with more context.
		return 0, fmt.Errorf("failed to marshal certificate to JSON: %w", err)
	}
	// The length of the byte slice is the size of the certificate in bytes.
	return len(jsonBytes), nil
}
</file>

<file path="tests/e2e/.keep">

</file>

<file path="tests/integration/.keep">

</file>

<file path="README.md">
# Go-Enterprise-APIs
Circular Protocol Go-lang Enterprise APIs
</file>

<file path=".github/workflows/tests_all.yml">
name: Run Tests

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Code
      uses: actions/checkout@v3

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: 1.24.4

    - name: Install Dependencies
      run: |
        go mod tidy
        go mod download

    - name: Run Tests
      run: |
        go test -v ./... # Runs all tests in the repository
</file>

<file path="pkg/account_test.go">
package circular_enterprise_apis

import (
	"encoding/hex"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	"github.com/decred/dcrd/dcrec/secp256k1/v4"
)


func TestOpen(t *testing.T) {
	testCases := []struct {
		name          string
		address       string
		expectError   bool
		expectedError string
	}{
		{
			name:          "Valid Address",
			address:       "0x1234567890abcdef",
			expectError:   false,
			expectedError: "",
		},
		{
			name:          "Empty Address",
			address:       "",
			expectError:   true,
			expectedError: "Invalid address format",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			acc := NewCEPAccount(DefaultChain, LibVersion)
			err := acc.Open(tc.address)

			if tc.expectError {
				if err == nil {
					t.Errorf("Expected an error but got nil")
				}
				if err.Error() != tc.expectedError {
					t.Errorf("Expected error message '%s', but got '%s'", tc.expectedError, err.Error())
				}
			} else {
				if err != nil {
					t.Errorf("Expected no error, but got: %v", err)
				}
				if acc.Address != tc.address {
					t.Errorf("Expected address to be '%s', but got '%s'", tc.address, acc.Address)
				}
			}
		})
	}
}

func TestUpdateAccount(t *testing.T) {
	testCases := []struct {
		name           string
		accountAddress string
		mockResponse   string
		mockStatusCode int
		expectSuccess  bool
		expectError    bool
		expectedNonce  int
	}{
		{
			name:           "Successful Update",
			accountAddress: "0x123",
			mockResponse:   `{"Result":200,"Response":{"Nonce":100}}`,
			mockStatusCode: http.StatusOK,
			expectSuccess:  true,
			expectError:    false,
			expectedNonce:  101,
		},
		{
			name:           "Account Not Open",
			accountAddress: "",
			mockResponse:   "",
			mockStatusCode: http.StatusOK,
			expectSuccess:  false,
			expectError:    true,
			expectedNonce:  0, // Nonce should not change from initial 0
		},
		{
			name:           "HTTP Error - Bad Status",
			accountAddress: "0x123",
			mockResponse:   "Internal Server Error",
			mockStatusCode: http.StatusInternalServerError,
			expectSuccess:  false,
			expectError:    true,
			expectedNonce:  0,
		},
		{
			name:           "Invalid JSON Response",
			accountAddress: "0x123",
			mockResponse:   `{"Result":200,"Response":{"Nonce":"invalid"}}`, // Nonce is not an int
			mockStatusCode: http.StatusOK,
			expectSuccess:  false,
			expectError:    true,
			expectedNonce:  0,
		},
		{
			name:           "Server Response Result Not 200",
			accountAddress: "0x123",
			mockResponse:   `{"Result":400,"Response":{"Nonce":100}}`,
			mockStatusCode: http.StatusOK,
			expectSuccess:  false,
			expectError:    true,
			expectedNonce:  0,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Create a mock HTTP server
			server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.WriteHeader(tc.mockStatusCode)
				w.Write([]byte(tc.mockResponse))
			}))
			defer server.Close()

			acc := NewCEPAccount(DefaultChain, LibVersion)
			if tc.accountAddress != "" {
				acc.Open(tc.accountAddress)
			}

			// Override NAGURL and NetworkNode to point to the mock server
			// Note: In a real scenario, these might be configured via dependency injection
			// or environment variables for easier testing.
			acc.NAGURL = server.URL + "/NAG.php?cep=" // Adjust to match the expected URL structure
			acc.NetworkNode = "mock_node"             // This part of the URL is appended by UpdateAccount

			success, err := acc.UpdateAccount()

			if tc.expectError {
				if err == nil {
					t.Errorf("Expected an error but got nil")
				}
			} else {
				if err != nil {
					t.Errorf("Expected no error, but got: %v", err)
				}
			}

			if success != tc.expectSuccess {
				t.Errorf("Expected success to be %v, but got %v", tc.expectSuccess, success)
			}

			if acc.Nonce != tc.expectedNonce {
				t.Errorf("Expected Nonce to be %d, but got %d", tc.expectedNonce, acc.Nonce)
			}
		})
	}
}

func TestSetNetwork(t *testing.T) {
	// Define a default NAG URL to check if it gets updated correctly.
	const initialNagURL = "https://default.nag.url"

	testCases := []struct {
		name              string
		network           string
		mockResponse      string
		mockStatusCode    int
		initialNetworkURL string // Base URL for fetching network info
		expectError       bool
		expectedErrorMsg  string
		expectedNagURL    string
	}{
		{
			name:              "Successful Network Set",
			network:           "mainnet",
			mockResponse:      `{"status":"success", "url":"https://new.nag.url/"}`,
			mockStatusCode:    http.StatusOK,
			initialNetworkURL: "", // Will be replaced by mock server URL
			expectError:       false,
			expectedNagURL:    "https://new.nag.url/",
		},
		{
			name:              "Failed Network Set - API Error",
			network:           "invalidnet",
			mockResponse:      `{"status":"error", "message":"Invalid network specified"}`,
			mockStatusCode:    http.StatusOK,
			initialNetworkURL: "",
			expectError:       true,
			expectedErrorMsg:  "failed to set network: Invalid network specified",
			expectedNagURL:    initialNagURL, // Should not change
		},
		{
			name:              "Failed Network Set - HTTP Error",
			network:           "mainnet",
			mockResponse:      "Internal Server Error",
			mockStatusCode:    http.StatusInternalServerError,
			initialNetworkURL: "",
			expectError:       true,
			expectedErrorMsg:  "network request failed with status: 500 Internal Server Error",
			expectedNagURL:    initialNagURL, // Should not change
		},
		{
			name:              "Failed Network Set - Invalid JSON",
			network:           "mainnet",
			mockResponse:      `{"status":"success", "url":}`,
			mockStatusCode:    http.StatusOK,
			initialNetworkURL: "",
			expectError:       true,
			expectedErrorMsg:  "failed to decode network response", // Check for substring
			expectedNagURL:    initialNagURL,
		},
		{
			name:              "Failed Network Set - Invalid Base URL",
			network:           "mainnet",
			mockResponse:      "",
			mockStatusCode:    0,
			initialNetworkURL: "://invalid-url", // Malformed URL to trigger a parsing error
			expectError:       true,
			expectedErrorMsg:  "invalid network URL", // Check for substring
			expectedNagURL:    initialNagURL,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Create a mock server for tests that need it.
			var server *httptest.Server
			if tc.mockStatusCode > 0 {
				server = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
					w.WriteHeader(tc.mockStatusCode)
					w.Write([]byte(tc.mockResponse))
				}))
				defer server.Close()
			}

			acc := NewCEPAccount(DefaultChain, LibVersion)
			acc.NAGURL = initialNagURL // Set initial NAG URL

			// Set the NetworkURL for the account.
			if tc.initialNetworkURL == "" && server != nil {
				// If no specific initialNetworkURL is provided, use the mock server's URL.
				acc.NetworkURL = server.URL + "/"
			} else {
				acc.NetworkURL = tc.initialNetworkURL
			}

			err := acc.SetNetwork(tc.network)

			if tc.expectError {
				if err == nil {
					t.Fatal("Expected an error but got nil")
				}
				if !strings.Contains(err.Error(), tc.expectedErrorMsg) {
					t.Errorf("Expected error message to contain '%s', but got '%s'", tc.expectedErrorMsg, err.Error())
				}
			} else {
				if err != nil {
					t.Fatalf("Expected no error, but got: %v", err)
				}
			}

			if acc.NAGURL != tc.expectedNagURL {
				t.Errorf("Expected NAGURL to be '%s', but got '%s'", tc.expectedNagURL, acc.NAGURL)
			}
		})
	}
}

func TestSignData(t *testing.T) {
	// Generate a new private key for testing
	privateKey, err := secp256k1.GeneratePrivateKey()
	if err != nil {
		t.Fatalf("Failed to generate private key: %v", err)
	}
	privateKeyHex := hex.EncodeToString(privateKey.Serialize())

	testCases := []struct {
		name          string
		dataToSign    []byte
		privateKeyHex string
		expectError   bool
	}{
		{
			name:          "Successful Signing",
			dataToSign:    []byte("test data to be signed"),
			privateKeyHex: privateKeyHex,
			expectError:   false,
		},
		{
			name:          "Invalid Private Key Hex",
			dataToSign:    []byte("some data"),
			privateKeyHex: "invalidhex",
			expectError:   true,
		},
		{
			name:          "Empty Data",
			dataToSign:    []byte(""),
			privateKeyHex: privateKeyHex,
			expectError:   false, // Signing empty data should still work
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			acc := NewCEPAccount(DefaultChain, LibVersion)

			signature, err := acc.SignData(tc.dataToSign, tc.privateKeyHex)

			if tc.expectError {
				if err == nil {
					t.Errorf("Expected an error but got nil")
				}
				if signature != "" {
					t.Errorf("Expected empty signature but got: %s", signature)
				}
			} else {
				if err != nil {
					t.Errorf("Expected no error, but got: %v", err)
				}
				if signature == "" {
					t.Errorf("Expected a non-empty signature but got empty")
				}
			}
		})
	}
}

func TestSignDataRFC6979(t *testing.T) {
	// Generate a new private key for testing.
	privateKey, err := secp256k1.GeneratePrivateKey()
	if err != nil {
		t.Fatalf("Failed to generate private key: %v", err)
	}
	privateKeyHex := hex.EncodeToString(privateKey.Serialize())

	acc := NewCEPAccount(DefaultNAG, DefaultChain, LibVersion)

	data := []byte("test message for RFC 6979")

	// Sign the same data twice.
	sig1, err1 := acc.SignData(data, privateKeyHex)
	if err1 != nil {
		t.Fatalf("First signature generation failed: %v", err1)
	}

	sig2, err2 := acc.SignData(data, privateKeyHex)
	if err2 != nil {
		t.Fatalf("Second signature generation failed: %v", err2)
	}

	// According to RFC 6979, signatures must be deterministic.
	if sig1 != sig2 {
		t.Errorf(`Signatures are not deterministic. RFC 6979 requires that signing the same data with the same key produces the same signature.
Sig1: %s
Sig2: %s`, sig1, sig2)
	}
}

func TestClose(t *testing.T) {
	acc := NewCEPAccount(DefaultNAG, DefaultChain, LibVersion)

	// Populate fields with dummy values
	
	acc.PublicKey = "testPublicKey"
	acc.Address = "testAddress"

	// Call the Close method
	acc.Close()

	// Assert that fields are cleared
	if acc.PublicKey != "" {
		t.Errorf("Expected PublicKey to be empty, but got %s", acc.PublicKey)
	}
	if acc.Address != "" {
		t.Errorf("Expected Address to be empty, but got %s", acc.Address)
	}
}


func TestSubmitCertificate(t *testing.T) {
	// Generate a new private key for testing
	privateKey, err := secp256k1.GeneratePrivateKey()
	if err != nil {
		t.Fatalf("Failed to generate private key: %v", err)
	}
	privateKeyHex := hex.EncodeToString(privateKey.Serialize())

	testCases := []struct {
		name             string
		pdata            string
		privateKey       string
		mockResponse     string
		mockStatusCode   int
		nagURL           string
		expectError      bool
		expectedErrorMsg string
		expectedResult   map[string]interface{}
	}{
		{
			name:            "Successful Submission",
			pdata:           "test data",
			privateKey:      privateKeyHex,
			mockResponse:    `{"Result":200, "TxID":"0x123"}`,
			mockStatusCode:  http.StatusOK,
			nagURL:          "http://localhost:8080",
			expectError:     false,
			expectedResult:  map[string]interface{}{"Result": float64(200), "TxID": "0x123"},
		},
		{
			name:             "NAGURL Not Set",
			pdata:            "test data",
			privateKey:       privateKeyHex,
			mockResponse:     "",
			mockStatusCode:   0,
			nagURL:           "",
			expectError:      true,
			expectedErrorMsg: "network is not set. Please call SetNetwork() first",
		},
		{
			name:             "Invalid Private Key",
			pdata:            "test data",
			privateKey:       "invalid",
			mockResponse:     "",
			mockStatusCode:   0,
			nagURL:           "http://localhost:8080",
			expectError:      true,
			expectedErrorMsg: "failed to sign data: invalid private key hex string",
		},
		{
			name:             "HTTP Error - Non-200 Status",
			pdata:            "test data",
			privateKey:       privateKeyHex,
			mockResponse:     "Internal Server Error",
			mockStatusCode:   http.StatusInternalServerError,
			nagURL:           "http://localhost:8080",
			expectError:      true,
			expectedErrorMsg: "network returned an error",
		},
		{
			name:             "Invalid JSON Response",
			pdata:            "test data",
			privateKey:       privateKeyHex,
			mockResponse:     `invalid json`,
			mockStatusCode:   http.StatusOK,
			nagURL:           "http://localhost:8080",
			expectError:      true,
			expectedErrorMsg: "failed to decode response JSON",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			var server *httptest.Server
			if tc.nagURL != "" {
				server = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
					w.WriteHeader(tc.mockStatusCode)
					w.Write([]byte(tc.mockResponse))
				}))
				defer server.Close()
			}

			acc := NewCEPAccount(DefaultChain, LibVersion)
			if tc.nagURL != "" {
				acc.NAGURL = server.URL
			} else {
				acc.NAGURL = ""
			}

			result, err := acc.SubmitCertificate(tc.pdata, tc.privateKey)

			if tc.expectError {
				if err == nil {
					t.Fatal("Expected an error but got nil")
				}
				if !strings.Contains(err.Error(), tc.expectedErrorMsg) {
					t.Errorf("Expected error message to contain '%s', but got '%s'", tc.expectedErrorMsg, err.Error())
				}
			} else {
				if err != nil {
					t.Fatalf("Expected no error, but got: %v", err)
				}
				if len(result) != len(tc.expectedResult) {
					t.Errorf("Expected result map length %d, but got %d", len(tc.expectedResult), len(result))
				}
				for k, v := range tc.expectedResult {
					if result[k] != v {
						t.Errorf("Expected result[%s] to be %v, but got %v", k, v, result[k])
					}
				}
			}
		})
	}
}

func TestGetTransactionByID(t *testing.T) {
	testCases := []struct {
		name             string
		transactionID    string
		startBlock       string
		endBlock         string
		mockResponse     string
		mockStatusCode   int
		nagURL           string
		expectError      bool
		expectedErrorMsg string
		expectedResult   map[string]interface{}
	}{
		{
			name:           "Successful GetTransactionByID",
			transactionID:  "0xabcdef123456",
			startBlock:     "",
			endBlock:       "",
			mockResponse:   `{"status":"success", "details":"transaction details by ID"}`,
			mockStatusCode: http.StatusOK,
			nagURL:         "http://localhost:8080",
			expectError:    false,
			expectedResult: map[string]interface{}{"status": "success", "details": "transaction details by ID"},
		},
		{
			name:           "Successful GetTransactionByID with Blocks",
			transactionID:  "0xabcdef123456",
			startBlock:     "100",
			endBlock:       "200",
			mockResponse:   `{"status":"success", "details":"transaction details by ID and blocks"}`,
			mockStatusCode: http.StatusOK,
			nagURL:         "http://localhost:8080",
			expectError:    false,
			expectedResult: map[string]interface{}{"status": "success", "details": "transaction details by ID and blocks"},
		},
		{
			name:             "NAGURL Not Set",
			transactionID:    "0xabcdef123456",
			startBlock:       "",
			endBlock:         "",
			mockResponse:     "",
			mockStatusCode:   0,
			nagURL:           "",
			expectError:      true,
			expectedErrorMsg: "network is not set. Please call SetNetwork() first",
		},
		{
			name:             "HTTP Error - Non-200 Status",
			transactionID:    "0xabcdef123456",
			startBlock:       "",
			endBlock:         "",
			mockResponse:     "Not Found",
			mockStatusCode:   http.StatusNotFound,
			nagURL:           "http://localhost:8080",
			expectError:      true,
			expectedErrorMsg: "network request failed with status: 404 Not Found",
		},
		{
			name:             "Invalid JSON Response",
			transactionID:    "0xabcdef123456",
			startBlock:       "",
			endBlock:         "",
			mockResponse:     `{"status":"success", "details":}`, // Malformed JSON
			mockStatusCode:   http.StatusOK,
			nagURL:           "http://localhost:8080",
			expectError:      true,
			expectedErrorMsg: "failed to decode transaction JSON",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			var server *httptest.Server
			if tc.nagURL != "" {
				server = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
					w.WriteHeader(tc.mockStatusCode)
					w.Write([]byte(tc.mockResponse))
				}))
				defer server.Close()
			}

			acc := NewCEPAccount(DefaultChain, LibVersion)
			if tc.nagURL != "" {
				acc.NAGURL = server.URL
			} else {
				acc.NAGURL = ""
			}

			result, err := acc.GetTransactionByID(tc.transactionID, tc.startBlock, tc.endBlock)

			if tc.expectError {
				if err == nil {
					t.Fatal("Expected an error but got nil")
				}
				if !strings.Contains(err.Error(), tc.expectedErrorMsg) {
					t.Errorf("Expected error message to contain '%s', but got '%s'", tc.expectedErrorMsg, err.Error())
				}
			} else {
				if err != nil {
					t.Fatalf("Expected no error, but got: %v", err)
				}
				if len(result) != len(tc.expectedResult) {
					t.Errorf("Expected result map length %d, but got %d", len(tc.expectedResult), len(result))
				}
				for k, v := range tc.expectedResult {
					if result[k] != v {
						t.Errorf("Expected result[%s] to be %v, but got %v", k, v, result[k])
					}
				}
			}
		})
	}
}


func TestGetTransactionOutcome(t *testing.T) {
	testCases := []struct {
		name             string
		TxID             string
		timeoutSec       int
		mockResponses    []string
		mockStatusCodes  []int
		nagURL           string
		expectError      bool
		expectedErrorMsg string
		expectedOutcome  map[string]interface{}
	}{
		{
			name:            "Successful Outcome - Not Pending",
			TxID:            "0x123",
			timeoutSec:      5,
			mockResponses:   []string{`{"Result":200, "Response":{"Status":"Pending"}}`, `{"Result":200, "Response":{"Status":"Confirmed", "Value":100}}`},
			mockStatusCodes: []int{http.StatusOK, http.StatusOK},
			nagURL:          "http://localhost:8080",
			expectError:     false,
			expectedOutcome: map[string]interface{}{"Status": "Confirmed", "Value": float64(100)},
		},
		{
			name:             "Timeout Exceeded",
			TxID:             "0x456",
			timeoutSec:       1,
			mockResponses:    []string{`{"Result":200, "Response":{"Status":"Pending"}}`, `{"Result":200, "Response":{"Status":"Pending"}}`},
			mockStatusCodes:  []int{http.StatusOK, http.StatusOK},
			nagURL:           "http://localhost:8080",
			expectError:      true,
			expectedErrorMsg: "timeout exceeded",
		},
		{
			name:             "NAGURL Not Set",
			TxID:             "0x789",
			timeoutSec:       1, // Short timeout since it should fail immediately
			mockResponses:    []string{},
			mockStatusCodes:  []int{},
			nagURL:           "",
			expectError:      true,
			expectedErrorMsg: "network is not set. Please call SetNetwork() first",
		},
		{
			name:             "HTTP Error During Polling",
			TxID:             "0xabc",
			timeoutSec:       5,
			mockResponses:    []string{`Internal Server Error`},
			mockStatusCodes:  []int{http.StatusInternalServerError},
			nagURL:           "http://localhost:8080",
			expectError:      true,
			expectedErrorMsg: "timeout exceeded", // Will eventually timeout if errors persist
		},
		{
			name:             "Invalid JSON Response During Polling",
			TxID:             "0xdef",
			timeoutSec:       5,
			mockResponses:    []string{`{"Result":200, "Response":{"Status":"Pending"}}`, `invalid json`},
			mockStatusCodes:  []int{http.StatusOK, http.StatusOK},
			nagURL:           "http://localhost:8080",
			expectError:      true,
			expectedErrorMsg: "timeout exceeded", // Will eventually timeout if errors persist
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			requestCount := 0
			var server *httptest.Server
			if tc.nagURL != "" {
				server = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
					if requestCount < len(tc.mockResponses) {
						w.WriteHeader(tc.mockStatusCodes[requestCount])
						w.Write([]byte(tc.mockResponses[requestCount]))
						requestCount++
					} else {
						w.WriteHeader(http.StatusOK)
						w.Write([]byte(`{"Result":200, "Response":{"Status":"Pending"}}`)) // Default to pending if no more mock responses
					}
				}))
				defer server.Close()
			}

			acc := NewCEPAccount(DefaultChain, LibVersion)
			acc.IntervalSec = 1 // Set a short interval for faster test execution
			if tc.nagURL != "" {
				acc.NAGURL = server.URL
			} else {
				acc.NAGURL = ""
			}

			outcome, err := acc.GetTransactionOutcome(tc.TxID, tc.timeoutSec)

			if tc.expectError {
				if err == nil {
					t.Fatal("Expected an error but got nil")
				}
				if !strings.Contains(err.Error(), tc.expectedErrorMsg) {
					t.Errorf("Expected error message to contain '%s', but got '%s'", tc.expectedErrorMsg, err.Error())
				}
			} else {
				if err != nil {
					t.Fatalf("Expected no error, but got: %v", err)
				}
				if len(outcome) != len(tc.expectedOutcome) {
					t.Errorf("Expected outcome map length %d, but got %d", len(tc.expectedOutcome), len(outcome))
				}
				for k, v := range tc.expectedOutcome {
					if outcome[k] != v {
						t.Errorf("Expected outcome[%s] to be %v, but got %v", k, v, outcome[k])
					}
				}
			}
		})
	}
}
</file>

<file path=".gitignore">
.cursor
.direnv
.windsurf
result
.envrc
.env*
target
flake.*
.aider*
*.java
*.js
.env.e2e
</file>

<file path="RFC-6979.md">
A Comprehensive Guide to Implementing RFC 6979 for Deterministic ECDSA Signatures in GoThe Criticality of the Nonce in ECDSA: A Secret Under ThreatTo fully appreciate the solution presented by RFC 6979, one must first understand the problem it so effectively solves. The Elliptic Curve Digital Signature Algorithm (ECDSA) is a cornerstone of modern cryptography, used in everything from TLS web security to blockchain transactions.1 At its heart lies a per-signature secret number, the nonce, whose proper handling is paramount to the security of the entire system.The Role of 'k': ECDSA's Ephemeral SecretIn the standard ECDSA signing process, a signer (Alice) with a private key d and a corresponding public key Q=dG (where G is a known base point on the elliptic curve) signs a message m through a series of steps.3A cryptographically secure random integer k, known as the nonce, is generated for this signature only. It must be kept secret.A point on the elliptic curve is calculated by multiplying the base point by the nonce: R=kG. The x-coordinate of this point, r, becomes the first component of the signature.The message m is cryptographically hashed, resulting in a value e.The second component of the signature, s, is calculated using the private key d, the message hash e, the value r, and the inverse of the nonce k:s=k1(e+dr)(modn)where n is the order of the curve's base point.The final signature is the pair (r,s). The nonce k is ephemeral; it is generated, used once, and should be discarded. However, for that single signature's lifecycle, the secrecy of k is as critical as the long-term secrecy of the private key d.This relationship can be better understood by reframing the nonce's role. If we rearrange the signature equation, we get sk=e+dr, which can be expressed as dr=ske. In this form, it becomes clear that the term sk acts as a cryptographic mask. Since s, r, and e are public, the private key d is protected only by the secrecy and unpredictability of k. The nonce functions as a one-time symmetric key or a one-time pad for the signature, encrypting the relationship between the private key and the message. If this ephemeral key is compromised, the entire system fails.The Perils of Flawed Nonce GenerationThe history of applied cryptography is littered with examples of catastrophic failures stemming from improper nonce generation. Any deviation from a perfectly random, secret, and unique nonce can lead to the complete recovery of the signer's private key.Nonce Reuse: The Classic AttackThe most well-known vulnerability is nonce reuse. If an attacker obtains two different messages, m1 and m2, signed with the same private key d and the same nonce k, they can recover the private key with trivial algebra.4Given two signatures, (r,s1) and (r,s2), for messages with hashes e1 and e2:s1=k1(e1+dr)(modn)s2=k1(e2+dr)(modn)The attacker can compute:s1s2=k1(e1e2)(modn)From this, they can solve for the nonce k:k=(e1e2)(s1s2)1(modn)Once k is known, the attacker can substitute it back into either of the original signature equations to solve for the private key d:d=r1(s1ke1)(modn)This is not a theoretical concern. It was precisely this vulnerability that allowed for the recovery of the code-signing private key for the Sony PlayStation 3 console, a landmark security failure in a major commercial product.3Predictable and Biased Nonces: The Subtle ThreatEven if a nonce is never reused, the system can be broken if it is predictable or statistically biased. Using a weak pseudo-random number generator (PRNG), like Math.random() in JavaScript, can produce a sequence of k values that an attacker can guess or reconstruct, leading to the same key recovery attack.4A more subtle and recent example is the high-profile PuTTY vulnerability (CVE-2024-31497). PuTTY used a custom deterministic nonce generation scheme that, due to a flawed modular reduction, produced nonces where the first 60 bits were heavily biased. This statistical flaw was sufficient to allow an attacker to recover the private key after observing a few dozen signatures.5 This case is particularly instructive because it demonstrates that even a well-intentioned attempt at deterministic generation can fail catastrophically if it deviates from a rigorously vetted standard. The core issue is that any property that distinguishes the nonce k from a truly uniform random number in the valid range can potentially be exploited.6RFC 6979: The Deterministic Nonce Generation StandardIn response to the clear and present danger of flawed nonce generation, RFC 6979, "Deterministic Usage of the Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA)," was developed and published.8 It provides a standardized method to generate the nonce k deterministically, eliminating the need for a source of high-quality randomness at the time of signing.From Randomness to Determinism: The Core PhilosophyThe fundamental principle of RFC 6979 is to derive the nonce k from the inputs that are already part of the signature process: the long-term secret (the private key d) and the message hash e.4 This approach provides several key benefits:Eliminates RNG Dependencies: It completely removes the reliance on an external, high-quality, and properly seeded cryptographically secure pseudo-random number generator (CSPRNG) during the critical signing operation.9 This eradicates the entire class of vulnerabilities associated with RNG failures, nonce reuse, and nonce bias.Maintains Compatibility: A crucial design feature is that the resulting signatures are standard ECDSA signatures. A verifier does not need to know that RFC 6979 was used; the signature can be validated using the standard ECDSA verification algorithm without any modification.11Enhances Testability: Because the signature for a given message and key is always the same, it simplifies the process of writing unit tests and debugging cryptographic implementations.6The HMAC-DRBG Mechanism UnveiledThe procedure defined in RFC 6979 is far more sophisticated than a simple hash like `hash(d || e)`. It employs a mechanism based on HMAC-based Deterministic Random Bit Generator (HMAC-DRBG) to produce a nonce that is cryptographically indistinguishable from a uniformly random value.4The algorithm, as detailed in the RFC 9, proceeds as follows:Initialization: Two state values, K and V, are initialized. K is set to a string of zero bytes, and V is set to a string of one bytes, both with a length equal to the output length of the chosen hash function (e.g., 32 bytes for SHA-256).Seeding: The state is seeded with the private key d (denoted as x in the RFC) and the message hash e (denoted as h1) through a series of HMAC operations. This securely mixes the secret key and the message data into the internal state. The specific construction is:$K = \text{HMAC}_K(V \ || \ 0x00 \ || \ \text{int2octets}(x) \ || \ \text{bits2octets}(h_1))$*   V=HMACK(V)*   $K = \text{HMAC}_K(V \ || \ 0x01 \ || \ \text{int2octets}(x) \ || \ \text{bits2octets}(h_1))$*   V=HMACK(V)3.  Generation Loop: A loop begins to generate candidate bits for the nonce. In each iteration, the state is updated (V=HMACK(V)), and the result is appended to a temporary sequence T. This continues until T contains enough bits to form a number of the same bit-length as the curve order q.4.  Rejection Sampling: The bit sequence T is converted into an integer, which becomes the candidate nonce k. This candidate is then checked to ensure it falls within the valid range [1,q1]. If k=0 or kq, it is rejected.5.  Loop on Rejection: If the candidate k is rejected, the state is updated again ($K = \text{HMAC}_K(V || 0x00)$, V=HMACK(V)), and the generation loop (Step 3) is re-executed to produce a new candidate. This process repeats until a valid k is found.This rejection sampling step is the critical feature that prevents the kind of modulo bias seen in the PuTTY vulnerability. It ensures that the final nonce k is uniformly distributed across the valid range, a property that simpler methods fail to provide.5 The complexity of this procedure is not arbitrary; it is a carefully designed defense-in-depth mechanism that codifies a "pit of success" for developers. By following this standard, an implementer is protected not only from obvious RNG failures but also from the subtle, hard-to-detect statistical flaws that can arise from custom, "good enough" solutions.Security Profile: Benefits and Inherent RisksThe primary benefit of RFC 6979 is its immunity to the entire class of attacks based on flawed randomness.1 However, by making the signature process deterministic, it introduces a different, albeit more difficult, attack vector: fault injection.If an attacker can induce a transient hardware or software fault (e.g., via voltage glitching or radiation) during the HMAC-DRBG process, they might be able to cause the same nonce k to be generated for two different messages. This would re-enable the classic key recovery attack.4 This is an advanced attack that requires physical proximity or control over the signing device's environment. This risk is being actively addressed in the cryptographic community through proposals for "hedged signatures," which mix the deterministic output with a small amount of external randomness to thwart fault attacks.13Native Implementation: Using the Go Standard Library (crypto/ecdsa)For many developers, the most direct and secure path to implementing RFC 6979 is by using the capabilities built directly into the Go standard library. The Go team has provided a simple, idiomatic way to generate deterministic signatures for the most common elliptic curves.The crypto/ecdsa Package's Built-in CapabilityThe key to this functionality lies in the crypto.Signer interface and its Sign method. The Go standard library's crypto/ecdsa package contains a powerful design choice: to generate a deterministic RFC 6979 signature, a developer calls the PrivateKey.Sign method, passing a nil value for the io.Reader that would normally supply randomness.14This contrasts with the traditional method of generating a randomized signature, which involves calling ecdsa.SignASN1 with a source of randomness like crypto/rand.Reader.15 The Go documentation notes that even this randomized method is hardened against weak RNGs by mixing the provided entropy with the private key and message hash, but the deterministic path offers absolute protection from any RNG-related failure.15This API design is an exemplar of the "pit of success" philosophy. Instead of adding a new, separate function like SignRFC6979, the Go team overloaded the behavior of the existing standard Sign method. This means any code written against the generic crypto.Signer interface can support deterministic signatures without modification. The choice is pushed to the caller, and using a nil interface value as a signal for special behavior is a common and natural pattern for Go developers, reducing API clutter and the risk of misconfiguration.Tutorial: Generating Deterministic Signatures with crypto/ecdsaThe following is a complete, runnable Go program that demonstrates the generation and verification of a deterministic ECDSA signature using the standard library.Gopackage main

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"log"
)

func main() {
	// 1. Generate a new ECDSA private key using the P-256 curve.
	// The standard library's RFC 6979 implementation supports P-224, P-256, P-384, and P-521.
	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err!= nil {
		log.Fatalf("Failed to generate private key: %v", err)
	}
	publicKey := &privateKey.PublicKey

	// 2. Prepare the message to be signed.
	// The Sign method operates on a hash of the message, not the raw message.
	message :=byte("This is a message to be signed deterministically.")
	hash := sha256.Sum256(message)

	// 3. Sign the message hash deterministically according to RFC 6979.
	// This is triggered by passing 'nil' as the io.Reader (first argument).
	// The third argument, crypto.SignerOpts, must specify the hash function used.
	// For SHA-256, we can pass crypto.SHA256.
	deterministicSignature, err := privateKey.Sign(nil, hash[:], crypto.SHA256)
	if err!= nil {
		log.Fatalf("Failed to sign message deterministically: %v", err)
	}

	fmt.Printf("Deterministic Signature (hex): %s\n", hex.EncodeToString(deterministicSignature))

	// 4. Verify the signature using the public key.
	// The standard ecdsa.VerifyASN1 function works without modification.
	isValid := ecdsa.VerifyASN1(publicKey, hash[:], deterministicSignature)
	if!isValid {
		log.Fatal("Signature verification failed!")
	}
	fmt.Println("Signature successfully verified.")

	// 5. Demonstrate determinism.
	// Signing the same message with the same key again will produce the exact same signature.
	deterministicSignature2, err := privateKey.Sign(nil, hash[:], crypto.SHA256)
	if err!= nil {
		log.Fatalf("Failed to sign message a second time: %v", err)
	}

	if hex.EncodeToString(deterministicSignature) == hex.EncodeToString(deterministicSignature2) {
		fmt.Println("Success: The second signature is identical, proving determinism.")
	} else {
		log.Fatal("Failure: The second signature was different.")
	}
}
Constraints and ConsiderationsWhen using the native implementation, developers must be aware of two key constraints:Supported Curves: The built-in RFC 6979 functionality is only available for the NIST curves defined in the crypto/elliptic package: P-224, P-256, P-384, and P-521. Attempting to use it with any other curve, such as secp256k1, will result in an error.14Hash Function Matching: The crypto.SignerOpts parameter passed to the Sign method must correctly identify the hash algorithm that was used to produce the digest. If sha256.Sum256 is used, the option must be crypto.SHA256 (or an equivalent struct).14For developers wishing to inspect the implementation, the relevant logic resides in the signRFC6979 function within the crypto/ecdsa/ecdsa.go source file.14 The correctness of this implementation is validated against the RFC's own test vectors in ecdsa_test.go.18A Survey of Third-Party Libraries for RFC 6979 in GoWhile the standard library is the ideal choice for NIST curves, many applications, particularly in the blockchain space, require curves that it does not support. This necessitates the use of third-party libraries.Beyond the Standard Library: When to Use External PackagesThe single most common reason to seek an external package for ECDSA is the need to use the secp256k1 curve. This curve is the standard for Bitcoin, Ethereum, and a vast number of other cryptocurrencies and related technologies.6 Since Go's native crypto/ecdsa package does not support deterministic signing for secp256k1, developers must turn to the rich ecosystem of community-maintained libraries. This bifurcation of the ecosystem is not a sign of fragmentation but rather a mature division of labor, where the Go team maintains general-purpose cryptographic primitives and specialized communities focus on high-performance, audited implementations for their specific needs.Library Analysis and Code TutorialsThe Specialist: github.com/decred/dcrd/dcrec/secp256k1/v4/ecdsaThis package, part of the Decred cryptocurrency project, is a highly optimized, pure-Go implementation of ECDSA tailored specifically for the secp256k1 curve. It is widely regarded as a de facto standard in the Go blockchain community. Its Sign function produces deterministic, canonical signatures compliant with RFC 6979 by default.20A code example for this library is straightforward:Gopackage main

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"log"

	"github.com/decred/dcrd/dcrec/secp256k1/v4"
	"github.com/decred/dcrd/dcrec/secp256k1/v4/ecdsa"
)

func main() {
	// 1. Generate a secp256k1 private key.
	privateKey, err := secp256k1.GeneratePrivateKey()
	if err!= nil {
		log.Fatalf("Failed to generate private key: %v", err)
	}
	publicKey := privateKey.PubKey()

	// 2. Hash the message.
	message :=byte("A message for the secp256k1 world.")
	hash := sha256.Sum256(message)

	// 3. Sign the hash. The Sign function is deterministic by default.
	signature := ecdsa.Sign(privateKey, hash[:])

	fmt.Printf("secp256k1 Signature (DER-encoded hex): %s\n", hex.EncodeToString(signature.Serialize()))

	// 4. Verify the signature.
	isValid := signature.Verify(hash[:], publicKey)
	if!isValid {
		log.Fatal("Signature verification failed!")
	}
	fmt.Println("secp256k1 signature successfully verified.")
}
The Modular Tool: github.com/kklash/rfc6979This package is a small, focused library that implements only the RFC 6979 nonce generation algorithm; it does not perform the actual ECDSA signing.21 Its purpose is to generate the nonce k, which a developer would then need to pass to a low-level signing function that allows manual specification of the nonce. While excellent for educational purposes or building custom cryptographic protocols, for standard curves like secp256k1, using an integrated library like decred/dcrd is strongly preferred to avoid the risk of integration errors.The library's API involves creating a Q struct with the curve's order and calling the Nonce method 21:Go// Example of generating a nonce 'k'
q := rfc6979.NewQ(curve.Params().N) // N is the curve order
privateKeyInt := privateKey.D
messageHash := sha256.Sum256(byte("message"))
k := q.Nonce(privateKeyInt, messageHash[:], sha256.New)
// 'k' would then be used in a low-level signing function.
Historical Libraries: apisit/rfc6979 and othersOlder libraries such as github.com/apisit/rfc6979 (published in 2014) and github.com/MixinNetwork/bitshares-go/sign/rfc6979 also exist.11 While historically important, they are not recommended for new projects. The Go cryptographic landscape has evolved significantly, and modern, actively maintained libraries that have undergone more intense scrutiny, such as decred/dcrd, are far safer choices.Comparative Analysis of Implementation OptionsThe following table provides a clear comparison to guide the selection process.Featurecrypto/ecdsa (Standard Library)decred/dcrd/dcrec/secp256k1/v4/ecdsakklash/rfc6979Primary Use CaseGeneral-purpose signing with standard NIST curves.High-performance, production-grade signing for secp256k1.Standalone, curve-agnostic RFC 6979 nonce generation.Supported CurvesP-224, P-256, P-384, P-521 only.14secp256k1 only.20Curve-agnostic; requires curve order q as input.21API AbstractionHigh-level. Signing is a single method call: priv.Sign(nil,...).14High-level. Signing is a single function call: ecdsa.Sign(priv,...).20Low-level. Generates only the nonce k: q.Nonce(...).21Maintenance StatusActively maintained by the Go core team.Actively maintained by the Decred project.Stable but less recent activity.Primary AudienceGeneral Go developers, enterprise applications.Blockchain/cryptocurrency developers.Cryptography implementers, researchers, educators.RecommendationDefault choice for all supported NIST curves.Recommended choice for all secp256k1 applications.Use only if building a custom signing framework for an unsupported curve.Production-Hardening and Final RecommendationsThe complexity of modern cryptography means that a developer's primary security responsibility has shifted from algorithm implementation to the careful selection and integration of audited, standard components. Making the right architectural choice is the most critical security decision.The Cardinal Rule: Do Not Implement Your Own CryptographyThe PuTTY vulnerability serves as the ultimate cautionary tale. The catastrophic failure was not the result of a bad RNG but of creating a custom deterministic nonce scheme that was subtly but fatally flawed. The developers were aware of RFC 6979 but chose not to adopt it, incorrectly assessing their own implementation as "close enough".5 This underscores the paramount importance of using standard, well-audited libraries. The Go team invests heavily in the security of its crypto packages, including subjecting them to external audits, and leveraging this work is a developer's most effective security measure.22A Clear Decision Framework for ImplementationTo implement RFC 6979 securely in Go, developers should follow this simple decision framework:Identify the elliptic curve required by the application.If the curve is a NIST standard (P-224, P-256, P-384, or P-521):Use the standard library's crypto/ecdsa package.Generate the signature by calling privateKey.Sign(nil, digest, opts).This is the most secure, simple, and dependency-free option.If the curve is secp256k1:Use the github.com/decred/dcrd/dcrec/secp256k1/v4/ecdsa package.Generate the signature by calling ecdsa.Sign(privateKey, hash).This is the industry-standard, audited choice for this curve in Go.If the curve is any other non-standard or exotic curve:This path enters expert territory. The first step should be to rigorously question the need for a non-standard curve.If proceeding is unavoidable, it will require combining a modular nonce generator like kklash/rfc6979 with a low-level ECDSA implementation that accepts a pre-computed nonce. This approach carries a significantly higher risk of implementation error and requires expert-level cryptographic review.Auditing, Maintenance, and VerificationWhen choosing a library, prioritize those that are actively maintained and have a history of security scrutiny.7 A library like decred/dcrd, which is central to a live cryptocurrency, is subject to intense and continuous review from a community with strong financial incentives to find flaws. Regardless of the library chosen, it is good practice to verify that its implementation passes the official RFC 6979 test vectors, a sign of correctness that both the Go standard library and reputable third-party libraries adhere to.18ConclusionGo provides excellent, secure, and accessible tools for implementing deterministic ECDSA signatures according to RFC 6979. By understanding the critical and historically perilous role of the nonce, developers can appreciate the profound security benefits of this standard. The Go standard library offers a robust, built-in solution for NIST curves that is both simple and idiomatic. For the widely used secp256k1 curve, the community has produced high-quality, specialized libraries that are considered industry standards. By following the clear decision framework outlined in this report to select the appropriate, audited library for their chosen curve, a Go developer can confidently implement deterministic signatures that are resilient to the most common and dangerous classes of ECDSA attacks.
</file>

<file path="pkg/account.go">
package circular_enterprise_apis

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/lessuselesss/CEP-Go-APIs/internal/utils"
	"github.com/decred/dcrd/dcrec/secp256k1/v4"
	decdsa "github.com/decred/dcrd/dcrec/secp256k1/v4/ecdsa"
)

// CEPAccount holds the data for a Circular Enterprise Protocol account.
type CEPAccount struct {
	Address     string
	PublicKey   string
	Info        interface{}
	CodeVersion string
	LastError   string
	NAGURL      string
	NetworkNode string
	Blockchain  string
	LatestTxID  string
	Nonce       int
	Data        map[string]interface{}
	IntervalSec int
	NetworkURL  string
}

// NewCEPAccount is a factory function that creates and initializes a new CEPAccount.
func NewCEPAccount(chain, version string) *CEPAccount {
	return &CEPAccount{
		CodeVersion: LibVersion,
		NetworkURL:  NetworkURL,
		NAGURL:      "",
		Blockchain:  DefaultChain,
		Nonce:       0,
		Data:        make(map[string]interface{}),
		IntervalSec: 2,
	}
}

// Open sets the account address. This is a prerequisite for many other
// account operations. It takes the account address as a string and
// returns an error if the address is invalid.
func (a *CEPAccount) Open(address string) error {
	if address == "" {
		return errors.New("Invalid address format")
	}
	a.Address = address
	return nil
}

// UpdateAccount fetches the latest account information from the blockchain
// via the NAG (Network Access Gateway). It updates the account's public key,
// nonce, and other network-related details.
func (a *CEPAccount) UpdateAccount() (bool, error) {
	if a.Address == "" {
		return false, errors.New("Account is not open")
	}

	// Prepare the request payload
	requestData := struct {
		Blockchain string `json:"Blockchain"`
		Address    string `json:"Address"`
		Version    string `json:"Version"`
	}{
		Blockchain: a.Blockchain,
		Address:    a.Address,
		Version:    a.CodeVersion,
	}

	jsonData, err := json.Marshal(requestData)
	if err != nil {
		return false, fmt.Errorf("failed to marshal request data: %w", err)
	}

	// Construct the full URL for the API endpoint
	url := fmt.Sprintf("%s/Circular_GetWalletNonce_%s", a.NAGURL, a.NetworkNode)

	// Make the HTTP POST request
	resp, err := http.Post(url, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return false, fmt.Errorf("http post request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return false, fmt.Errorf("network request failed with status: %s", resp.Status)
	}

	// Read the entire body of the HTTP response.
	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return false, fmt.Errorf("failed to read response body: %w", err)
	}

	// Unmarshal the JSON response into a map
	var responseMap map[string]interface{}
	if err := json.Unmarshal(bodyBytes, &responseMap); err != nil {
		return false, fmt.Errorf("failed to decode response body: %w", err)
	}

	// Check for a successful result
	if result, ok := responseMap["Result"].(float64); ok && result == 200 {
		if response, ok := responseMap["Response"].(map[string]interface{}); ok {
			if nonce, ok := response["Nonce"].(float64); ok {
				a.Nonce = int(nonce) + 1
				return true, nil
			}
		}
		return false, errors.New("failed to parse nonce from response")
	} else if errMsg, ok := responseMap["Response"].(string); ok {
		return false, fmt.Errorf("server returned error: %s", errMsg)
	}

	return false, errors.New("failed to update account, invalid response from server")
}

// SetNetwork configures the account to use a specific blockchain network.
// It fetches the correct Network Access Gateway (NAG) URL for the given
// network identifier (e.g., "devnet", "testnet", "mainnet") and updates the
// NAG_URL field on the CEPAccount struct. A custom network URL can also be used.
func (a *CEPAccount) SetNetwork(network string) error {
	a.NetworkNode = network // Set the network node

	nagURL, err := GetNAG(network)
	if err != nil {
		return fmt.Errorf("failed to get NAG URL for network %s: %w", network, err)
	}
	a.NAGURL = nagURL

	return nil
}

// Close securely clears all sensitive credential data from the CEPAccount instance.
// It zeroes out the private key, public key, address, and permissions fields.
// It is a best practice to call this method when the account object is no longer
// needed to prevent sensitive data from lingering in the application's memory.
func (a *CEPAccount) Close() {
	// Setting the fields to their zero value effectively clears them.
	a.PublicKey = ""
	a.Address = ""
}

// SignData creates a cryptographic signature for the given data using the
// provided private key. It operates by first hashing the input data with
// SHA-256 and then signing the resulting hash using ECDSA with the secp256k1 curve.
//
// The dataToSign parameter is the raw data to be signed.
// The privateKeyHex parameter is the hex-encoded private key string.
//
// It returns the signature as a hex-encoded string in ASN.1 DER format.
// An error is returned if the private key is invalid or if the
// signing process fails.
func (a *CEPAccount) SignData(dataToSign []byte, privateKeyHex string) (string, error) {
	// Decode the hex-encoded private key string into a byte slice.
	privateKeyBytes, err := hex.DecodeString(utils.HexFix(privateKeyHex))
	if err != nil {
		return "", fmt.Errorf("invalid private key hex string: %w", err)
	}

	// Parse the private key bytes into a secp256k1.PrivateKey object.
	privateKey := secp256k1.PrivKeyFromBytes(privateKeyBytes)
	if privateKey == nil {
		return "", fmt.Errorf("failed to parse private key from bytes")
	}

	// Hash the input data using SHA-256. The signing algorithm operates on a
	// fixed-size hash of the data, not the raw data itself.
	hasher := sha256.New()
	hasher.Write(dataToSign)
	hashedData := hasher.Sum(nil)

	// Sign the hashed data with the private key using the secp256k1 library.
	// The Sign function from decred/dcrd/dcrec/secp256k1/v4/ecdsa is deterministic by default.
	signature := decdsa.Sign(privateKey, hashedData)

	// The signature is returned as a raw byte slice. We need to serialize it to DER format
	// for compatibility, as the original function returned ASN.1 DER.
	return hex.EncodeToString(signature.Serialize()), nil
}



// GetTransactionByID retrieves the details of a specific transaction from the blockchain
// using its unique transaction ID, and optionally a start and end block.
//
// The transactionID parameter is the unique string identifying the transaction.
// The startBlock and endBlock parameters are optional and can be empty strings.
//
// On success, it returns a map[string]interface{} containing the transaction
// details. An error is returned if the NAG_URL is not set, the network request
// fails, or the response body cannot be properly parsed.
func (a *CEPAccount) GetTransactionByID(transactionID, startBlock, endBlock string) (map[string]interface{}, error) {
	// A Network Access Gateway URL must be configured to identify the target network.
	if a.NAGURL == "" {
		return nil, fmt.Errorf("network is not set. Please call SetNetwork() first")
	}

	// Prepare the request payload
	requestData := struct {
		TxID  string `json:"TxID"`
		Start string `json:"Start"`
		End   string `json:"End"`
	}{
		TxID:  transactionID,
		Start: startBlock,
		End:   endBlock,
	}

	jsonData, err := json.Marshal(requestData)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request data: %w", err)
	}

	// Construct the full URL for the API endpoint
	requestURL := fmt.Sprintf("%s/Circular_GetTransactionbyID_%s", a.NAGURL, a.NetworkNode)

	// Make the HTTP POST request
	resp, err := http.Post(requestURL, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("http post request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("network request failed with status: %s", resp.Status)
	}

	// Read the entire body of the HTTP response.
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Unmarshal the JSON response into a map. This provides a flexible structure
	// for accessing transaction data, which can have a variable schema.
	var transactionDetails map[string]interface{}
	if err := json.Unmarshal(body, &transactionDetails); err != nil {
		return nil, fmt.Errorf("failed to decode transaction JSON: %w", err)
	}

	return transactionDetails, nil
}

// SubmitCertificate sends a given certificate to the blockchain for processing
// and inclusion. It serializes the certificate object into a JSON payload and
// submits it to the account's configured Network Access Gateway (NAG) URL.
//
// The 'pdata' parameter is the raw data to be included in the certificate.
// The 'privateKey' parameter is the private key used for signing.
//
// On success, it returns a map[string]interface{} containing the response from
// the network, which typically includes a transaction hash. An error is returned
// if the NAG_URL is not set, if the certificate cannot be serialized, or if the
// network request fails.
func (a *CEPAccount) SubmitCertificate(pdata string, privateKey string) (map[string]interface{}, error) {
	// A Network Access Gateway URL must be configured to identify the target network.
	if a.NAGURL == "" {
		return nil, fmt.Errorf("network is not set. Please call SetNetwork() first")
	}

	// Create the PayloadObject
	payloadObject := map[string]interface{}{
		"data": pdata,
	}

	// Marshal PayloadObject to JSON string
	payloadObjectBytes, err := json.Marshal(payloadObject)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal payload object: %w", err)
	}
	payload := hex.EncodeToString(payloadObjectBytes)

	// Generate Timestamp
	timestamp := utils.GetFormattedTimestamp()

	// Construct the string for hashing
	str := fmt.Sprintf("%s%s%s%s", a.Address, a.NetworkNode, payload, timestamp)

	// Generate ID using SHA-256
	hasher := sha256.New()
	hasher.Write([]byte(str))
	id := hex.EncodeToString(hasher.Sum(nil))

	// Call SignData to get the Signature
	signature, err := a.SignData([]byte(str), privateKey)
	if err != nil {
		return nil, fmt.Errorf("failed to sign data: %w", err)
	}

	// Construct the final data payload for the HTTP request
	requestData := map[string]interface{}{
		"ID":         id,
		"From":       utils.HexFix(a.Address),
		"To":         utils.HexFix(a.Address),
		"Timestamp":  timestamp,
		"Payload":    payload,
		"Nonce":      fmt.Sprintf("%d", a.Nonce),
		"Signature":  signature,
		"Blockchain": a.Blockchain,
		"Type":       "C_TYPE_CERTIFICATE",
		"Version":    a.CodeVersion,
	}

	jsonData, err := json.Marshal(requestData)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request data: %w", err)
	}

	// Construct the full URL for the API endpoint
	requestURL := fmt.Sprintf("%s/Circular_AddTransaction_%s", a.NAGURL, a.NetworkNode)

	// Create a new HTTP POST request. The body of the request is the JSON payload.
	req, err := http.NewRequest("POST", requestURL, bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	// Execute the HTTP request using a default client.
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to submit certificate: %w", err)
	}
	defer resp.Body.Close()

	// Read the response from the network.
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for non-successful HTTP status codes.
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("network returned an error - status: %s, body: %s", resp.Status, string(body))
	}

	// Unmarshal the JSON response into a map for flexible access to the result.
	var responseMap map[string]interface{}
	if err := json.Unmarshal(body, &responseMap); err != nil {
		return nil, fmt.Errorf("failed to decode response JSON: %w", err)
	}

	
	return responseMap, nil
}

// GetTransactionOutcome retrieves the final processing result of a transaction
// from the blockchain using its unique ID. This is often used to confirm
// whether a submitted transaction was successfully validated and included in a block.
//
// The 'transactionID' parameter is the unique string identifying the transaction.
//
// It returns a map[string]interface{} containing the outcome details on success.
// An error is returned if the NAG_URL is not configured, the network request fails,
// or the JSON response cannot be parsed.
func (a *CEPAccount) GetTransactionOutcome(TxID string, timeoutSec int) (map[string]interface{}, error) {
	if a.NAGURL == "" {
		return nil, fmt.Errorf("network is not set. Please call SetNetwork() first")
	}
	startTime := time.Now()
	timeout := time.Duration(timeoutSec) * time.Second

	for {
		elapsedTime := time.Since(startTime)
		if elapsedTime > timeout {
			return nil, fmt.Errorf("timeout exceeded")
		}

		data, err := a.GetTransactionByID(TxID, "", "")
		if err != nil {
			// Continue polling even if there's an error, in case it's a temporary issue
			fmt.Printf("Error fetching transaction: %v, polling again...\n", err)
		} else {
			// Check for a definitive status
			if result, ok := data["Result"].(float64); ok && result == 200 {
				if response, ok := data["Response"].(map[string]interface{}); ok {
					if status, ok := response["Status"].(string); ok && status != "Pending" {
						return response, nil // Resolve if transaction is found and not pending
					}
				}
			}
		}

		fmt.Println("Transaction not yet confirmed or not found, polling again...")
		time.Sleep(time.Duration(a.IntervalSec) * time.Second) // Continue polling
	}
}
</file>

<file path="internal/utils/utils_test.go">
package utils

import (
	"strings"
	"testing"
	"time"
)

func TestGetFormattedTimestamp(t *testing.T) {
	// Call the function to get the formatted timestamp
	timestamp := GetFormattedTimestamp()

	// Split the timestamp into date and time parts
	parts := strings.Split(timestamp, "-")
	if len(parts) != 2 {
		t.Errorf("Timestamp does not have the expected format (YYYY:MM:DD-HH:MM:SS). Received: %s", timestamp)
		return
	}

	// Validate the date part
	dateParts := strings.Split(parts[0], ":")
	if len(dateParts) != 3 {
		t.Errorf("Date part does not have the expected format (YYYY:MM:DD). Received: %s", parts[0])
		return
	}

	// Validate the time part
	timeParts := strings.Split(parts[1], ":")
	if len(timeParts) != 3 {
		t.Errorf("Time part does not have the expected format (HH:MM:SS). Received: %s", parts[1])
		return
	}

	// Ensure the timestamp represents a valid time
	parsedTime, err := time.Parse("2006:01:02-15:04:05", timestamp)
	if err != nil {
		t.Errorf("Timestamp is not valid. Error: %v", err)
		return
	}

	// Ensure the parsed time is close to the current time (within a few seconds)
	now := time.Now().UTC()
	diff := now.Sub(parsedTime)
	if diff.Seconds() > 5 || diff.Seconds() < -5 {
		t.Errorf("Timestamp is not close to the current UTC time. Difference: %v seconds", diff.Seconds())
	}
}

func TestPadNumber(t *testing.T) {
	// Test case for a single-digit number
	t.Run("single digit", func(t *testing.T) {
		result := PadNumber(5)
		expected := "05"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	// Test case for a double-digit number
	t.Run("double digit", func(t *testing.T) {
		result := PadNumber(12)
		expected := "12"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	// Test case for zero
	t.Run("zero", func(t *testing.T) {
		result := PadNumber(0)
		expected := "00"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	// Test case for the boundary condition
	t.Run("boundary ten", func(t *testing.T) {
		result := PadNumber(10)
		expected := "10"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	// TODO: Review the expected behavior for negative numbers with the originator.
	// The current implementation does not handle negative numbers in the same way as the corrected Go function.
	// Test case for a negative number
	// t.Run("negative single digit", func(t *testing.T) {
	// 	result := padNumber(-5)
	// 	expected := "-05"
	// 	if result != expected {
	// 		t.Errorf("Expected %s, but got %s", expected, result)
	// 	}
	// })
}

func TestHexFix(t *testing.T) {
	t.Run("with prefix", func(t *testing.T) {
		result := HexFix("0x123")
		expected := "123"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	t.Run("without prefix", func(t *testing.T) {
		result := HexFix("123")
		expected := "123"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	t.Run("empty string", func(t *testing.T) {
		result := HexFix("")
		expected := ""
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	t.Run("only prefix", func(t *testing.T) {
		result := HexFix("0x")
		expected := ""
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	t.Run("prefix in middle", func(t *testing.T) {
		result := HexFix("10x23")
		expected := "10x23"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})
}

func TestStringToHex(t *testing.T) {
	t.Run("ascii string", func(t *testing.T) {
		result := StringToHex("hello")
		expected := "68656c6c6f"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	t.Run("empty string", func(t *testing.T) {
		result := StringToHex("")
		expected := ""
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	t.Run("string with numbers and symbols", func(t *testing.T) {
		result := StringToHex("123!@#")
		expected := "313233214023"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})
}

func TestHexToString(t *testing.T) {
	t.Run("valid hex string", func(t *testing.T) {
		result := HexToString("68656c6c6f")
		expected := "hello"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

		t.Run("with 0x prefix", func(t *testing.T) {
		result := HexToString("0x68656c6c6f")
		expected := "hello"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

		t.Run("empty string", func(t *testing.T) {
		result := HexToString("")
		expected := ""
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

		t.Run("invalid hex string", func(t *testing.T) {
		result := HexToString("invalid")
		expected := ""
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

		t.Run("with null byte", func(t *testing.T) {
		result := HexToString("68656c006c6f")
		expected := "hello"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})
}
</file>

<file path="tests/integration/circular_enterprise_apis_integration_test.go">
package integration

import (
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"

	"github.com/joho/godotenv"
	cep "github.com/lessuselesss/CEP-Go-APIs/pkg"
)

func TestMain(m *testing.M) {
	// Load .env file from the current directory (tests/integration)
	// This makes the environment variables available to the tests
	err := godotenv.Load()
	if err != nil {
		// If the .env file is not found, we don't fail the test,
		// as the tests are designed to skip if the env vars are not set.
		// We just log that it wasn't loaded.
		fmt.Println("Error loading .env file, tests requiring env vars will be skipped.")
	}
	// Run the tests
	os.Exit(m.Run())
}

func TestCircularOperations(t *testing.T) {
	privateKeyHex := os.Getenv("CIRCULAR_PRIVATE_KEY")
	address := os.Getenv("CIRCULAR_ADDRESS")
	if privateKeyHex == "" || address == "" {
		t.Skip("Skipping test: CIRCULAR_PRIVATE_KEY and CIRCULAR_ADDRESS environment variables must be set")
	}

	// Create a mock server to handle network requests
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if strings.Contains(r.URL.Path, "GetWalletNonce") {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"Result":200,"Response":{"Nonce":1}}`))
		} else if strings.Contains(r.URL.Path, "Circular_GetTransactionbyID_") {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"Result":200,"Response":{"Status":"Confirmed"}}`))
		} else if strings.Contains(r.URL.Path, "transaction") {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"Result":200,"Response":{"Status":"Confirmed"}}`))
		} else {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"txHash":"0x12345","status":"success"}`))
		}
	}))
	defer server.Close()

	acc := cep.NewCEPAccount("testnet", "1.0")

	// Decode the private key and set it on the account

	var err error
	err = acc.Open(address)
	if err != nil {
		t.Fatalf("acc.Open() failed: %v", err)
	}

	ok, err := acc.UpdateAccount()
	if !ok || err != nil {
		t.Fatalf("acc.UpdateAccount() failed: ok=%v, err=%v", ok, err)
	}

	var resp map[string]interface{}
	resp, err = acc.SubmitCertificate("test message", privateKeyHex)
	if err != nil {
		t.Fatalf("acc.SubmitCertificate() failed: %v", err)
	}

	txHash, ok := resp["txHash"].(string)
	if !ok {
		t.Fatal("txHash not found in response")
	}

	var outcome map[string]interface{}
	outcome, err = acc.GetTransactionOutcome(txHash, 10)
	if err != nil {
		t.Fatalf("acc.GetTransactionOutcome() failed: %v", err)
	}

	if status, _ := outcome["Status"].(string); status != "Confirmed" {
		t.Errorf("Expected transaction status to be 'Confirmed', but got '%s'", status)
	}

	// TODO: Implement TestCircularOperations
}

func TestCertificateOperations(t *testing.T) {
	privateKeyHex := os.Getenv("CIRCULAR_PRIVATE_KEY")
	address := os.Getenv("CIRCULAR_ADDRESS")
	if privateKeyHex == "" || address == "" {
		t.Skip("Skipping test: CIRCULAR_PRIVATE_KEY and CIRCULAR_ADDRESS environment variables must be set")
	}

	// Create a mock server to handle network requests
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if strings.Contains(r.URL.Path, "GetWalletNonce") {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"Result":200,"Response":{"Nonce":1}}`))
		} else if strings.Contains(r.URL.Path, "Circular_GetTransactionbyID_") {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"Result":200,"Response":{"Status":"Confirmed"}}`))
		} else {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"txHash":"0x12345","status":"success"}`))
		}
	}))
	defer server.Close()

	acc := cep.NewCEPAccount("testnet", "1.0")

	var err error
	err = acc.Open(address)
	if err != nil {
		t.Fatalf("acc.Open() failed: %v", err)
	}

	ok, err := acc.UpdateAccount()
	if !ok || err != nil {
		t.Fatalf("acc.UpdateAccount() failed: ok=%v, err=%v", ok, err)
	}

	resp, err := acc.SubmitCertificate("test certificate data", privateKeyHex)
	if err != nil {
		t.Fatalf("acc.SubmitCertificate() failed: %v", err)
	}

	txHash, ok := resp["txHash"].(string)
	if !ok {
		t.Fatal("txHash not found in response")
	}

	outcome, err := acc.GetTransactionOutcome(txHash, 10)
	if err != nil {
		t.Fatalf("acc.GetTransactionOutcome() failed: %v", err)
	}

	if status, _ := outcome["Status"].(string); status != "Confirmed" {
		t.Errorf("Expected transaction status to be 'Confirmed', but got '%s'", status)
	}
}

func TestHelloWorldCertification(t *testing.T) {
	privateKeyHex := os.Getenv("CIRCULAR_PRIVATE_KEY")
	address := os.Getenv("CIRCULAR_ADDRESS")
	if privateKeyHex == "" || address == "" {
		t.Skip("Skipping test: CIRCULAR_PRIVATE_KEY and CIRCULAR_ADDRESS environment variables must be set")
	}

	// Create a mock server to handle network requests
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if strings.Contains(r.URL.Path, "GetWalletNonce") {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"Result":200,"Response":{"Nonce":1}}`))
		} else if strings.Contains(r.URL.Path, "Circular_GetTransactionbyID_") {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"Result":200,"Response":{"Status":"Confirmed"}}`))
		} else {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"txHash":"0x12345","status":"success"}`))
		}
	}))
	defer server.Close()

	acc := cep.NewCEPAccount("testnet", "1.0")

	var err error
	err = acc.Open(address)
	if err != nil {
		t.Fatalf("acc.Open() failed: %v", err)
	}

	ok, err := acc.UpdateAccount()
	if !ok || err != nil {
		t.Fatalf("acc.UpdateAccount() failed: ok=%v, err=%v", ok, err)
	}

	resp, err := acc.SubmitCertificate("Hello World", privateKeyHex)
	if err != nil {
		t.Fatalf("acc.SubmitCertificate() failed: %v", err)
	}

	txHash, ok := resp["txHash"].(string)
	if !ok {
		t.Fatal("txHash not found in response")
	}

	outcome, err := acc.GetTransactionOutcome(txHash, 10)
	if err != nil {
		t.Fatalf("acc.GetTransactionOutcome() failed: %v", err)
	}

	if status, _ := outcome["Status"].(string); status != "Confirmed" {
		t.Errorf("Expected transaction status to be 'Confirmed', but got '%s'", status)
	}
}
</file>

<file path="pkg/circular_enterprise_apis_test.go">
package circular_enterprise_apis

import (
	"fmt"
	"io"
	"net/http"
	"strings"
	"testing"
)


// TestNewAccount verifies that the NewAccount method correctly initializes an Account instance
// with the parent CEP's network configuration.
func TestNewAccount(t *testing.T) {
	acc := NewCEPAccount(DefaultChain, LibVersion)

	if acc == nil {
		t.Fatal("NewAccount returned nil")
	}
	if acc.NAGURL != DefaultNAG {
		t.Errorf("Expected NAGURL to be %s, got %s", DefaultNAG, acc.NAGURL)
	}
}

// TestNewCertificate verifies that the NewCertificate method correctly initializes a Certificate instance
// with the parent CEP's network configuration.
func TestNewCertificate(t *testing.T) {
	cert := NewCertificate(LibVersion)

	if cert == nil {
		t.Fatal("NewCertificate returned nil")
	}
	if cert.Version != LibVersion {
		t.Errorf("Expected Version to be %s, got %s", LibVersion, cert.Version)
	}
}

// mockRoundTripper is a custom http.RoundTripper for mocking HTTP responses in tests.
type mockRoundTripper struct {
	response *http.Response
	err      error
}

func (m *mockRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	return m.response, m.err
}

// errorReader is an io.Reader that always returns an error.
type errorReader struct{}

func (e *errorReader) Read(p []byte) (n int, err error) {
	return 0, fmt.Errorf("i/o error")
}

// TestGetNAG tests the network discovery function.
func TestGetNAG(t *testing.T) {
	originalTransport := http.DefaultClient.Transport
	defer func() {
		http.DefaultClient.Transport = originalTransport
	}()

	t.Run("SuccessfulDiscovery", func(t *testing.T) {
		expectedNAG := "https://test-nag.circularlabs.io/"
		http.DefaultClient.Transport = &mockRoundTripper{
			response: &http.Response{
				StatusCode: http.StatusOK,
				Body:       io.NopCloser(strings.NewReader(expectedNAG)),
			},
		}

		nag, err := GetNAG("testnet")
		if err != nil {
			t.Fatalf("Expected no error, but got %v", err)
		}
		if nag != expectedNAG {
			t.Errorf("Expected NAG URL %s, but got %s", expectedNAG, nag)
		}
	})

	t.Run("FailedDiscovery", func(t *testing.T) {
		http.DefaultClient.Transport = &mockRoundTripper{
			err: fmt.Errorf("network error"),
		}

		_, err := GetNAG("testnet")
		if err == nil {
			t.Fatal("Expected an error, but got none")
		}
	})

	t.Run("Non200StatusCode", func(t *testing.T) {
		http.DefaultClient.Transport = &mockRoundTripper{
			response: &http.Response{
				StatusCode: http.StatusNotFound,
				Body:       io.NopCloser(strings.NewReader("Not Found")),
			},
		}

		body, err := GetNAG("testnet")
		if err != nil {
			t.Fatalf("Expected no error based on current implementation, but got %v", err)
		}
		if body != "Not Found" {
			t.Errorf("Expected body 'Not Found', but got '%s'", body)
		}
	})

	t.Run("BodyReadError", func(t *testing.T) {
		http.DefaultClient.Transport = &mockRoundTripper{
			response: &http.Response{
				StatusCode: http.StatusOK,
				Body:       io.NopCloser(&errorReader{}),
			},
		}

		_, err := GetNAG("testnet")
		if err == nil {
			t.Fatal("Expected an error due to body read failure, but got none")
		}
	})

	t.Run("EmptyNetworkString", func(t *testing.T) {
		expectedNAG := "https://default-nag.circularlabs.io/"
		http.DefaultClient.Transport = &mockRoundTripper{
			response: &http.Response{
				StatusCode: http.StatusOK,
				Body:       io.NopCloser(strings.NewReader(expectedNAG)),
			},
		}

		nag, err := GetNAG("")
		if err != nil {
			t.Fatalf("Expected no error for empty network string, but got %v", err)
		}
		if nag != expectedNAG {
			t.Errorf("Expected NAG URL %s, but got %s", expectedNAG, nag)
		}
	})
}




func TestCertificateOperations(t *testing.T) {
	// TODO: Implement TestCertificateOperations
}

func TestHelloWorldCertification(t *testing.T) {
	// TODO: Implement TestHelloWorldCertification
}
</file>

<file path="main.go">
package main

import (
	"log"

	"github.com/joho/godotenv"
)

func main() {
	// Load environment variables from .env file
	err := godotenv.Load()
	if err != nil {
		log.Printf("Error loading .env file: %v", err)
		// Optionally, you can exit here if .env is critical
		// os.Exit(1)
	}

	// This is the main entry point for the application.
	// The test suite targets the library packages, not this executable.

	// Example of accessing an environment variable:
	// circularAddress := os.Getenv("CIRCULAR_ADDRESS")
	// if circularAddress != "" {
	// 	log.Printf("CIRCULAR_ADDRESS: %s", circularAddress)
	// }
}
</file>

<file path="internal/utils/utils.go">
package utils

import (
	"encoding/hex"
	"fmt"
	"strings"
	"time"
)

// PadNumber adds a leading zero to numbers less than 10.
func PadNumber(num int) string {
	if num < 10 {
		return fmt.Sprintf("0%d", num)
	}
	return fmt.Sprintf("%d", num)
}

// GetFormattedTimestamp generates a UTC timestamp in YYYY:MM:DD-HH:MM:SS format.
func GetFormattedTimestamp() string {
	now := time.Now().UTC()
	year := now.Year()
	month := PadNumber(int(now.Month()))
	day := PadNumber(now.Day())
	hours := PadNumber(now.Hour())
	minutes := PadNumber(now.Minute())
	seconds := PadNumber(now.Second())
	return fmt.Sprintf("%d:%s:%s-%s:%s:%s", year, month, day, hours, minutes, seconds)
}

// HexFix removes '0x' prefix from hexadecimal strings if present.
func HexFix(word string) string {
	if strings.HasPrefix(word, "0x") {
		return word[2:]
	}
	return word
}

// StringToHex converts a string to its hexadecimal representation.
func StringToHex(str string) string {
	return hex.EncodeToString([]byte(str))
}

// HexToString converts a hexadecimal string back to its original string form.
func HexToString(hexStr string) string {
	cleanedHex := HexFix(hexStr)
	bytes, err := hex.DecodeString(cleanedHex)
	if err != nil {
		return ""
	}
	// Strip null bytes to match the reference implementation
	return strings.ReplaceAll(string(bytes), "\x00", "")
}
</file>

<file path="pkg/circular_enterprise_apis.go">
package circular_enterprise_apis

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
)

// Constants define default network parameters and library metadata.
const (
	// LibVersion specifies the current version of the library.
	LibVersion = "1.0.13"

	// NetworkURL is the base endpoint for discovering a Network Access Gateway (NAG).
	NetworkURL = "https://circularlabs.io/network/getNAG?network="

	// DefaultChain is the blockchain identifier for the default public network.
	DefaultChain = "0x8a20baa40c45dc5055aeb26197c203e576ef389d9acb171bd62da11dc5ad72b2"

	// DefaultNAG is the URL for the default public Network Access Gateway.
	DefaultNAG = "https://nag.circularlabs.io/NAG.php?cep="
)


// GetNAG is a standalone utility function for discovering the NAG URL for a
// given network identifier. It makes an HTTP request to the public NetworkURL endpoint.
func GetNAG(network string) (string, error) {
	resp, err := http.Get(NetworkURL + network)
	if err != nil {
		return "", fmt.Errorf("failed to fetch NAG URL: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read response body: %w", err)
	}

	var nagResponse struct {
		URL string `json:"url"`
	}

	if err := json.Unmarshal(body, &nagResponse); err != nil {
		return "", fmt.Errorf("failed to unmarshal NAG response: %w", err)
	}

	if nagResponse.URL == "" {
		return "", fmt.Errorf("NAG URL not found in response: %s", string(body))
	}

	return nagResponse.URL, nil
}
</file>

<file path="go.mod">
module github.com/lessuselesss/CEP-Go-APIs

go 1.24.4

require (
	github.com/circular-protocol/circular-go v0.0.0-20241027102342-f2ff57add44b
	github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0
)

require (
	github.com/btcsuite/btcd/chaincfg/chainhash v1.0.1 // indirect
	github.com/decred/dcrd/dcrec/secp256k1 v1.0.4 // indirect
	github.com/decred/dcrd/dcrec/secp256k1/v2 v2.0.0 // indirect
	github.com/joho/godotenv v1.5.1 // indirect
)
</file>

</files>
</file>

<file path="new_audit_findings.md">
# Go Library Alignment Plan

This document outlines the step-by-step plan to align the Go-lang library with the reference Java and Node.js implementations. Each step will be a separate commit with a descriptive message following the `fix/[logic-to-be-fixed]` convention.

## Step 1: Foundational Utilities (`internal/utils`)

*   **Branch:** `fix/utils-alignment`
*   **Objective:** Ensure the utility functions in `internal/utils/utils.go` are consistent with the helper functions in the reference implementations. This is a low-risk starting point as these functions have no dependencies within the Go library itself.
*   **Tasks:**
    1.  **`PadNumber`:** Verify that the logic is identical to the `padNumber` function in the Node.js implementation.
    2.  **`GetFormattedTimestamp`:** The current implementation is correct.
    3.  **`HexFix`:** The current implementation is correct.
    4.  **`StringToHex` and `HexToString`:** The current implementation is correct.

## Step 2: Certificate Handling (`pkg/certificate`)

*   **Branch:** `fix/certificate-logic`
*   **Objective:** Align the `Certificate` struct and its methods with the `C_CERTIFICATE` class in the Node.js implementation and the implicit certificate handling in the Java implementation.
*   **Tasks:**
    1.  **`NewCertificate`:** The current implementation is correct.
    2.  **`SetData` and `GetData`:** The current implementation is correct.
    3.  **`GetJSONCertificate` and `GetCertificateSize`:** The current implementation is correct.

## Step 3: Core Account Functionality (`pkg/account`)

*   **Branch:** `fix/account-core`
*   **Objective:** Align the core, non-network-dependent functionality of the `CEPAccount` struct.
*   **Tasks:**
    1.  **`NewCEPAccount`:** The current implementation is correct.
    2.  **`Open`:** The current implementation is correct.
    3.  **`Close`:** The current implementation is correct.

## Step 4: Network and Blockchain Interaction (`pkg/account`)

*   **Branch:** `fix/account-network`
*   **Objective:** Align the methods responsible for interacting with the blockchain network.
*   **Tasks:**
    1.  **`SetNetwork`:** The current implementation is correct.
    2.  **`UpdateAccount`:** The current implementation is correct.
    3.  **`GetTransaction` and `GetTransactionByID`:** The current implementation is correct.
    4.  **`GetTransactionOutcome`:** The current implementation is correct.

## Step 5: Cryptographic Signing (`pkg/account`)

*   **Branch:** `fix/account-signing`
*   **Objective:** Align the `SignData` method with the reference implementations. This is a critical and complex piece of logic that depends on the rest of the account functionality being correct.
*   **Tasks:**
    1.  **`SignData`:** The current implementation uses `decred/dcrd` for deterministic signing, which is a suitable replacement for the `elliptic` and `BouncyCastle` libraries used in the reference implementations. The key is to ensure the data being signed is hashed in the same way (SHA-256) and that the signature is DER-encoded.

## Step 6: Certificate Submission (`pkg/account`)

*   **Branch:** `fix/certificate-submission`
*   **Objective:** Align the `SubmitCertificate` method. This is the final step, bringing together all the other components.
*   **Tasks:**
    1.  **`SubmitCertificate`:** The current implementation is correct.

## Step 7: Top-Level API (`pkg`)

*   **Branch:** `fix/toplevel-api`
*   **Objective:** Ensure the main entry points of the library are consistent with the reference implementations.
*   **Tasks:**
    1.  **`NewCEP`:** The current implementation is correct.
    2.  **`NewAccount`:** The current implementation is correct.
    3.  **`NewCertificate`:** The current implementation is correct.
    4.  **`GetNAG`:** The current implementation is correct.
</file>

<file path="nodejs_go_audit_findings.md">
# Node.js vs. Go Implementation Audit Findings

This document outlines the differences identified between the Node.js reference implementation (`reference-nodejs-implementation.js`) and the Go implementation (`pkg/account.go`, `pkg/circular_enterprise_apis.go`, `internal/utils/utils.go`).

## Summary of Key Differences

## 1. Helper Functions

### Node.js Helper Functions:
- `padNumber(num)`: Adds a leading zero to numbers less than 10.
- `getFormattedTimestamp()`: Returns a UTC timestamp in `YYYY:MM:DD-HH:MM:SS` format.
- `HexFix(word)`: Removes '0x' prefix from hexadecimal strings.
- `stringToHex(str)`: Converts a string to its hexadecimal representation.
- `hexToString(hex)`: Converts a hexadecimal string back to its original string form.

### Go Helper Functions (`internal/utils/utils.go`):
- `PadNumber(num int)`: Equivalent to Node.js `padNumber`.
- `GetFormattedTimestamp()`: Equivalent to Node.js `getFormattedTimestamp`.
- `HexFix(word string)`: Equivalent to Node.js `HexFix`.
- `StringToHex(str string)`: Equivalent to Node.js `stringToHex`.
- `HexToString(hexStr string)`: Equivalent to Node.js `hexToString`.

### Differences/Notes:
- The Go implementation of `HexToString` explicitly handles stripping null bytes (`\x00`) to match the behavior of the Node.js version, which implicitly handles this due to JavaScript's string handling.
- The Go `GetFormattedTimestamp` uses `time.Now().UTC()` and `fmt.Sprintf` to format the timestamp, while the Node.js version uses `Date` object methods. Both achieve the same `YYYY:MM:DD-HH:MM:SS` format.
- The Go `GetFormattedTimestamp` in `circular_enterprise_apis.go` returns a Unix timestamp as a string, which is different from the `YYYY:MM:DD-HH:MM:SS` format in `internal/utils/utils.go` and the Node.js implementation. This needs to be aligned.

## 2. Certificate Structure and Operations

### Node.js (`C_CERTIFICATE` class):
- `data`: Stores the certificate data (hex-encoded).
- `previousTxID`: Stores the previous transaction ID.
- `previousBlock`: Stores the previous block.
- `version`: Stores the code version.
- `setData(data)`: Sets the certificate data, converting it to hex.
- `getData()`: Retrieves the certificate data, converting it from hex.
- `getJSONCertificate()`: Returns the certificate as a JSON string.
- `getCertificateSize()`: Calculates the size of the certificate in bytes.

### Go (`Certificate` struct in `pkg/circular_enterprise_apis.go`):
- `Data`: Stores the certificate data (string).
- `PreviousTxID`: Stores the previous transaction ID.
- `PreviousBlock`: Stores the previous block.
- `Version`: Stores the version.
- `SetData(data string)`: Sets the certificate data.
- `GetData()`: Retrieves the certificate data.
- `GetJSONCertificate()`: Returns the certificate as a JSON string.
- `GetCertificateSize()`: Calculates the size of the certificate in bytes.

### Differences/Notes:
- **Data Encoding:** In Node.js, `setData` automatically converts the input `data` to hex, and `getData` converts it back. In Go, the `Data` field is a `string`, and the `SetData` and `GetData` methods do not perform hex encoding/decoding. This means the Go implementation expects the `data` to be already hex-encoded when `SetData` is called, or it will store raw string data. This is a significant difference that needs to be addressed for compatibility.
- **Constructor:** Node.js uses a constructor for `C_CERTIFICATE`. Go uses `NewCertificate` factory function.
- **`codeVersion` vs `LibVersion`:** Node.js uses `this.codeVersion` which is initialized from `LIB_VERSION`. Go uses `LibVersion` constant directly.

## 3. Account Structure and Operations

### Node.js (`CEP_Account` class):
- **Properties:** `address`, `publicKey`, `info`, `codeVersion`, `lastError`, `NAG_URL`, `NETWORK_NODE`, `blockchain`, `LatestTxID`, `Nonce`, `data`, `intervalSec`.
- `constructor()`: Initializes properties with default values.
- `open(address)`: Sets the account address.
- `updateAccount()`: Fetches account nonce from the NAG.
- `setNetwork(network)`: Fetches the NAG URL for a given network.
- `setBlockchain(chain)`: Sets the blockchain address.
- `close()`: Clears account data.
- `signData(data, privateKey)`: Signs data using `secp256k1` and `sha256`.
- `getTransaction(blockNum, txID)`: Searches for a transaction by ID and block number.
- `getTransactionbyID(TxID, Start, End)`: Searches for a transaction by ID within a block range.
- `submitCertificate(pdata, privateKey)`: Submits a certificate to the blockchain.
- `GetTransactionOutcome(TxID, timeoutSec)`: Polls for transaction outcome.

### Go (`CEPAccount` struct in `pkg/account.go`):
- **Properties:** `Address`, `PublicKey`, `Info`, `CodeVersion`, `LastError`, `NAGURL`, `NetworkNode`, `Blockchain`, `LatestTxID`, `Nonce`, `Data`, `IntervalSec`, `NetworkURL`, `PrivateKey`.
- `NewCEPAccount()`: Factory function to create and initialize `CEPAccount`.
- `Open(address string)`: Equivalent to Node.js `open`.
- `UpdateAccount()`: Equivalent to Node.js `updateAccount`.
- `SetNetwork(network string)`: Equivalent to Node.js `setNetwork`.
- `Close()`: Equivalent to Node.js `close`.
- `SignData(dataToSign []byte)`: Signs data using `sha256` and `decdsa.Sign`.
- `GetTransaction(transactionHash string)`: Retrieves transaction details by hash.
- `GetTransactionByID(transactionID string)`: Retrieves transaction details by ID.
- `SubmitCertificate(cert *Certificate)`: Submits a certificate.
- `GetTransactionOutcome(TxID string, timeoutSec int)`: Polls for transaction outcome.

### Differences/Notes:
- **Private Key Handling:** The Go `CEPAccount` struct has a `PrivateKey` field of type `*secp256k1.PrivateKey`, allowing it to hold the private key directly. The Node.js `CEP_Account` class does not store the private key; it's passed as an argument to `signData` and `submitCertificate`.
- **`SignData` Parameters:** In Node.js, `signData` takes `data` and `privateKey` as arguments. In Go, `SignData` takes `dataToSign []byte` and uses the `a.PrivateKey` field. This implies the private key needs to be set on the `CEPAccount` struct in Go before calling `SignData`.
- **`SubmitCertificate` Parameters:** In Node.js, `submitCertificate` takes `pdata` (payload data) and `privateKey`. In Go, `SubmitCertificate` takes a `*Certificate` object. The signing of the payload is handled internally within `submitCertificate` in Node.js, while in Go, the `Certificate` object is expected to be prepared (and potentially signed) before being passed to `SubmitCertificate`.
- **`GetTransaction` and `GetTransactionByID`:** The Node.js implementation has two `getTransaction` methods (one with `blockNum, txID` and another with `BlockID, TxID`) and `getTransactionbyID`. The Go implementation has `GetTransaction` (by hash) and `GetTransactionByID` (by ID). The Node.js `getTransaction` methods seem to combine block and transaction ID, while Go separates them. This needs careful review for functional equivalence.
- **Error Handling:** Go uses `error` return values for explicit error handling, while Node.js uses `try-catch` blocks and returns `false` or throws errors.
- **Network URL Initialization:** In Go, `NetworkURL` is initialized in `NewCEPAccount` from a constant. In Node.js, `NETWORK_URL` is a global constant.
- **`UpdateAccount` API Endpoint:** The Node.js `updateAccount` calls `Circular_GetWalletNonce_` endpoint. The Go `UpdateAccount` calls `GetWalletNonce` endpoint. The Node.js version appends `this.NETWORK_NODE` to the endpoint, which is not present in the Go version. This needs to be aligned.
- **`GetTransactionOutcome`:** The Node.js version uses `Promise` and `setTimeout` for polling, while the Go version uses a `for` loop with `time.Sleep`.

## 4. Cryptography and Hashing

### Node.js:
- **Hashing:** Uses `sha256` library for SHA-256 hashing.
- **Signing:** Uses `elliptic` library (`secp256k1` curve) for ECDSA signing.

### Go:
- **Hashing:** Uses `crypto/sha256` package for SHA-256 hashing.
- **Signing:** Uses `github.com/decred/dcrd/dcrec/secp256k1/v4/ecdsa` for ECDSA signing.

### Differences/Notes:
- Both implementations use SHA-256 for hashing and `secp256k1` for ECDSA signing. The underlying cryptographic primitives are consistent.
- The Go implementation uses `decdsa.Sign` which returns a raw byte slice, then `hex.EncodeToString(signature.Serialize())` is used to get the DER-encoded hex string. This is consistent with the Node.js `key.sign(msgHash).toDER('hex')`.

## 5. API Endpoints and Communication

### Node.js:
- Uses `node-fetch` for HTTP requests.
- API endpoints are constructed by concatenating `NAG_URL` with specific method names (e.g., `Circular_GetWalletNonce_`, `Circular_AddTransaction_`, `Circular_GetTransactionbyID_`).
- Appends `NETWORK_NODE` to some API calls.

### Go:
- Uses `net/http` package for HTTP requests.
- API endpoints are constructed by concatenating `NAGURL` with specific method names or paths (e.g., `GetWalletNonce`, `/transaction/`).
- Does not explicitly append `NetworkNode` to API calls in the same way as Node.js.

### Differences/Notes:
- **Endpoint Naming:** The Node.js implementation uses `Circular_` prefixes and appends `_` to method names in the URL (e.g., `Circular_GetWalletNonce_`). The Go implementation uses simpler method names (e.g., `GetWalletNonce`). This needs to be aligned for consistent API calls.
- **`NETWORK_NODE`:** The Node.js implementation appends `this.NETWORK_NODE` to some API calls (e.g., `Circular_GetWalletNonce_` and `Circular_AddTransaction_`). The Go implementation does not have an equivalent appending of `NetworkNode` to the URL. This is a significant difference that needs to be investigated and potentially aligned for correct communication with the backend.
- **Transaction Query Endpoints:** Node.js has `Circular_GetTransactionbyID_` which takes `Start` and `End` parameters. Go has `GetTransaction` and `GetTransactionByID` which seem to map to different endpoint structures (`/transaction/{hash}` or `/transaction/{id}`). This needs to be carefully reviewed to ensure the Go implementation is hitting the correct endpoints with the correct parameters for transaction queries.
- **HTTP Client:** Node.js uses `node-fetch`, Go uses `net/http`. Both are standard for their respective environments.

## 6. Dependencies

### Node.js:
- `elliptic`: For ECDSA cryptography.
- `sha256`: For SHA-256 hashing.
- `node-fetch`: For making HTTP requests.

### Go:
- `github.com/decred/dcrd/dcrec/secp256k1/v4`: For `secp256k1` curve and ECDSA signing.
- Standard library `crypto/sha256`: For SHA-256 hashing.
- Standard library `net/http`: For making HTTP requests.
- Standard library `encoding/hex`, `encoding/json`, `fmt`, `io`, `strings`, `time`, `bytes`, `net/url`.

### Differences/Notes:
- Both implementations rely on external libraries for cryptography and HTTP communication, but the specific libraries differ due to language ecosystems. The core cryptographic algorithms (SHA-256, secp256k1 ECDSA) are consistent.

## 7. Coding Style and Conventions

### Node.js:
- Uses JavaScript class-based structure.
- CamelCase for function and variable names.
- `this` keyword for class properties.
- `async/await` for asynchronous operations.

### Go:
- Uses Go structs and methods.
- PascalCase for exported functions and struct fields, camelCase for unexported.
- Explicit error handling with `error` return values.
- Goroutines and channels for concurrency (though not heavily used in the provided snippets).

### Differences/Notes:
- Significant differences in language paradigms (object-oriented vs. procedural/struct-based).
- Error handling is a major difference, with Go's explicit error returns contrasting with Node.js's `try-catch` and promise-based error handling.
- Naming conventions are standard for each language.

---
</file>

<file path="recommendations-account_test.md">
Of course. After reviewing the provided Go test file, I've identified several areas with potential issues and opportunities for improvement. The tests are generally well-structured using table-driven tests and proper mocking, but some refinements could enhance their robustness and maintainability.

Here are the key issues found in the test file:

-----

### 1\. Inconsistent Error Handling and Verification

There are inconsistencies in how error messages are verified across different test functions.

  * **Exact vs. Substring Matching**: In `TestOpen`, errors are checked with an exact match (`err.Error() != tc.expectedError`). However, in `TestSetNetwork`, `TestSubmitCertificate`, and others, errors are checked using `strings.Contains()`.
  * **Inconsistent Production Code Errors**: The tests for `TestGetTransaction` and `TestGetTransactionByID` reveal that the underlying functions produce slightly different error messages for similar failures.
      * **HTTP Error in `GetTransaction`**: `network returned an error: 404 Not Found`
      * **HTTP Error in `GetTransactionByID`**: `network returned a non-200 status code: 404 Not Found`

**Recommendation:**
Adopt a consistent strategy for error verification. Using `strings.Contains()` is generally more robust, as it's less likely to break if an error message is slightly changed (e.g., punctuation or capitalization). The inconsistency in production error messages should also be addressed in the main library code to ensure uniformity.

-----

### 2\. Limited Coverage for Input Validation

The test for the `Open` function only validates against a single invalid case: an empty address string.

```go
func TestOpen(t *testing.T) {
    testCases := []struct {
        // ...
    }{
        // ...
        {
            name:          "Empty Address",
            address:       "",
            expectError:   true,
            expectedError: "Invalid address format",
        },
    }
    // ...
}
```

**Recommendation:**
Expand the test cases to cover other potential invalid address formats to ensure the validation logic is comprehensive. Examples include:

  * Addresses with incorrect prefixes (e.g., not starting with "0x").
  * Addresses with invalid hexadecimal characters.
  * Addresses with incorrect lengths.

-----

### 3\. Brittle Mocking of URLs

In `TestUpdateAccount`, the test constructs a specific URL for the mock server, including the path and query parameters. This makes the test dependent on the implementation details of how the URL is built in the `UpdateAccount` function.

```go
// from TestUpdateAccount
acc.NAGURL = server.URL + "/NAG.php?cep=" // Adjust to match the expected URL structure
acc.NetworkNode = "mock_node"             // This part of the URL is appended by UpdateAccount
```

**Recommendation:**
Decouple the test from the URL construction logic. The mock server should only care about handling requests to its base URL. The function being tested (`UpdateAccount`) should be responsible for appending the necessary path and parameters. The test should only set the base URL (`acc.NAGURL = server.URL`). This makes the test more resilient to changes in the URL structure.

-----

### 4\. Missing Tests for Malformed JSON Payloads

The tests effectively check for syntactically invalid JSON (e.g., a truncated string), but they don't test for responses that are syntactically valid but structurally incorrect. For example, a successful response might be missing a required field like `"Response"` or `"Nonce"`.

```go
// from TestUpdateAccount
{
    name:           "Invalid JSON Response",
    accountAddress: "0x123",
    // This Nonce is a string instead of an int, which causes a unmarshalling error.
    mockResponse:   `{"Result":200,"Response":{"Nonce":"invalid"}}`, 
    mockStatusCode: http.StatusOK,
    expectSuccess:  false,
    expectError:    true,
    expectedNonce:  0,
},
```

**Recommendation:**
Add test cases to simulate responses where the JSON is valid, but the payload is missing expected fields. This ensures the code can gracefully handle unexpected API responses without causing a runtime panic (e.g., from a nil pointer dereference).

-----

### 5\. Stylistic Concern: Dot Imports

The file uses dot imports (`.`) to import the `account` and `certificate` packages.

```go
import (
    // ...
    . "github.com/lessuselesss/CEP-Go-APIs/pkg/account"
    . "github.com/lessuselesss/CEP-Go-APIs/pkg/certificate"
)
```

While this can make test code less verbose, it can also harm readability by obscuring where symbols like `NewCEPAccount` and `Certificate` originate. This can become a maintenance issue in larger codebases.

**Recommendation:**
It is generally recommended to avoid dot imports. Using a standard import and qualifying symbols with the package name (e.g., `account.NewCEPAccount`) makes the code clearer and easier to navigate.
</file>

<file path="pkg/certificate_test.go">
package circular_enterprise_apis

import (
	"encoding/hex"
	"encoding/json"
	"reflect"
	"testing"
)

func TestSetData(t *testing.T) {
	testCases := []struct {
		name string
		data string
	}{
		{
			name: "Simple ASCII string",
			data: "hello world",
		},
		{
			name: "Empty string",
			data: "",
		},
		{
			name: "String with numbers and symbols",
			data: "123!@#$",
		},
		{
			name: "Unicode string",
			data: ", ",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			cert := &Certificate{}
			cert.SetData(tc.data)

			expectedHex := hex.EncodeToString([]byte(tc.data))

			if cert.Data != expectedHex {
				t.Errorf("Expected Data to be '%s', but got '%s'", expectedHex, cert.Data)
			}
		})
	}
}

func TestGetData(t *testing.T) {
	testCases := []struct {
		name         string
		cert         Certificate
		expectedData string
		expectError  bool
	}{
		{
			name: "Simple ASCII string",
			cert: Certificate{
				Data: hex.EncodeToString([]byte("hello world")),
			},
			expectedData: "hello world",
			expectError:  false,
		},
		{
			name: "Unicode string",
			cert: Certificate{
				Data: hex.EncodeToString([]byte(", ")),
			},
			expectedData: ", ",
			expectError:  false,
		},
		{
			name: "Empty string",
			cert: Certificate{
				Data: "",
			},
			expectedData: "",
			expectError:  false,
		},
		{
			name: "Invalid hex data",
			cert: Certificate{
				Data: "this is not hex",
			},
			expectedData: "",
			expectError:  true,
		},
		{
			name: "Odd length hex string",
			cert: Certificate{
				Data: "123",
			},
			expectedData: "",
			expectError:  true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			data, err := tc.cert.GetData()

			if tc.expectError {
				if err == nil {
					t.Errorf("Expected an error, but got none")
				}
			} else {
				if err != nil {
					t.Errorf("Did not expect an error, but got: %v", err)
				}
				if data != tc.expectedData {
					t.Errorf("Expected data to be '%s', but got '%s'", tc.expectedData, data)
				}
			}
		})
	}
}

func TestGetJSONCertificate(t *testing.T) {
	testCases := []struct {
		name         string
		cert         Certificate
		expectedJSON string
		expectError  bool
	}{
		{
			name: "Full certificate",
			cert: Certificate{
				Data:          hex.EncodeToString([]byte("hello world")),
				PreviousTxID:  "txid123",
				PreviousBlock: "block456",
				Version:       "1.0.0",
			},
			expectedJSON: `{"data":"68656c6c6f20776f726c64","previousTxID":"txid123","previousBlock":"block456","version":"1.0.0"}`,
			expectError:  false,
		},
		{
			name:         "Empty certificate",
			cert:         Certificate{},
			expectedJSON: `{"data":"","previousTxID":"","previousBlock":"","version":""}`,
			expectError:  false,
		},
		{
			name: "Certificate with some empty fields",
			cert: Certificate{
				Data:    hex.EncodeToString([]byte("some data")),
				Version: "1.1.0",
			},
			expectedJSON: `{"data":"736f6d652064617461","previousTxID":"","previousBlock":"","version":"1.1.0"}`,
			expectError:  false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			jsonString, err := tc.cert.GetJSONCertificate()

			if tc.expectError {
				if err == nil {
					t.Errorf("Expected an error, but got none")
				}
				return
			}

			if err != nil {
				t.Errorf("Did not expect an error, but got: %v", err)
			}

			var resultData, expectedData map[string]interface{}

			err = json.Unmarshal([]byte(jsonString), &resultData)
			if err != nil {
				t.Fatalf("Failed to unmarshal actual JSON string: %v", err)
			}

			err = json.Unmarshal([]byte(tc.expectedJSON), &expectedData)
			if err != nil {
				t.Fatalf("Failed to unmarshal expected JSON string: %v", err)
			}

			if !reflect.DeepEqual(resultData, expectedData) {
				t.Errorf("Expected JSON \n%s\n, but got \n%s", tc.expectedJSON, jsonString)
			}
		})
	}
}

func TestGetCertificateSize(t *testing.T) {
	testCases := []struct {
		name         string
		cert         Certificate
		expectedSize int
		expectError  bool
	}{
		{
			name: "Full certificate",
			cert: Certificate{
				Data:          hex.EncodeToString([]byte("hello world")),
				PreviousTxID:  "txid123",
				PreviousBlock: "block456",
				Version:       "1.0.0",
			},
			expectedSize: 103,
			expectError:  false,
		},
		{
			name:         "Empty certificate",
			cert:         Certificate{},
			expectedSize: 61,
			expectError:  false,
		},
		{
			name: "Certificate with unicode data",
			cert: Certificate{
				Data: hex.EncodeToString([]byte(", ")),
			},
			expectedSize: 89,
			expectError:  false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			size, err := tc.cert.GetCertificateSize()

			if tc.expectError {
				if err == nil {
					t.Errorf("Expected an error, but got none")
				}
				return
			}

			if err != nil {
				t.Errorf("Did not expect an error, but got: %v", err)
			}

			if size != tc.expectedSize {
				t.Errorf("Expected size to be %d, but got %d", tc.expectedSize, size)
			}
		})
	}
}
</file>

<file path="pkg/certificate.go">
package circular_enterprise_apis

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
)

// Certificate represents a CIRCULAR certificate.
type Certificate struct {
	Data          string `json:"data"`
	PreviousTxID  string `json:"previousTxID"`
	PreviousBlock string `json:"previousBlock"`
	Version       string `json:"version"`
}

// NewCertificate creates and initializes a new Certificate instance.
func NewCertificate(version string) *Certificate {
	return &Certificate{
		Version: version,
	}
}

// SetData inserts application data into the certificate after converting it to a hexadecimal string.
// The `data` parameter is the string data to be stored.
func (c *Certificate) SetData(data string) {
	c.Data = hex.EncodeToString([]byte(data))
}

// GetData decodes the hexadecimal data from the certificate into a string.
// It returns the decoded string and an error if the data is not a valid hexadecimal format.
func (c *Certificate) GetData() (string, error) {
	decodedData, err := hex.DecodeString(c.Data)
	if err != nil {
		return "", fmt.Errorf("failed to decode certificate data: %w", err)
	}
	return string(decodedData), nil
}

// GetJSONCertificate serializes the certificate into a JSON string.
// It returns the JSON string and an error if the serialization fails.
func (c *Certificate) GetJSONCertificate() (string, error) {
	// The json.Marshal function converts the struct into a JSON byte slice.
	jsonBytes, err := json.Marshal(c)
	if err != nil {
		// Using fmt.Errorf to wrap the original error with more context.
		return "", fmt.Errorf("failed to marshal certificate to JSON: %w", err)
	}
	// Convert the byte slice to a string for the return value.
	return string(jsonBytes), nil
}

// GetCertificateSize calculates the size of the JSON-serialized certificate in bytes.
// It returns the size and an error if the serialization fails.
func (c *Certificate) GetCertificateSize() (int, error) {
	// The json.Marshal function converts the struct into a JSON byte slice.
	jsonBytes, err := json.Marshal(c)
	if err != nil {
		// Using fmt.Errorf to wrap the original error with more context.
		return 0, fmt.Errorf("failed to marshal certificate to JSON: %w", err)
	}
	// The length of the byte slice is the size of the certificate in bytes.
	return len(jsonBytes), nil
}
</file>

<file path="tests/e2e/.keep">

</file>

<file path="tests/integration/.keep">

</file>

<file path="README.md">
# Go-Enterprise-APIs
Circular Protocol Go-lang Enterprise APIs
</file>

<file path=".github/workflows/tests_all.yml">
name: Run Tests

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Code
      uses: actions/checkout@v3

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: 1.24.4

    - name: Install Dependencies
      run: |
        go mod tidy
        go mod download

    - name: Run Tests
      run: |
        go test -v ./... # Runs all tests in the repository
</file>

<file path="pkg/account_test.go">
package circular_enterprise_apis

import (
	"encoding/hex"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	"github.com/decred/dcrd/dcrec/secp256k1/v4"
)


func TestOpen(t *testing.T) {
	testCases := []struct {
		name          string
		address       string
		expectError   bool
		expectedError string
	}{
		{
			name:          "Valid Address",
			address:       "0x1234567890abcdef",
			expectError:   false,
			expectedError: "",
		},
		{
			name:          "Empty Address",
			address:       "",
			expectError:   true,
			expectedError: "Invalid address format",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			acc := NewCEPAccount(DefaultChain, LibVersion)
			err := acc.Open(tc.address)

			if tc.expectError {
				if err == nil {
					t.Errorf("Expected an error but got nil")
				}
				if err.Error() != tc.expectedError {
					t.Errorf("Expected error message '%s', but got '%s'", tc.expectedError, err.Error())
				}
			} else {
				if err != nil {
					t.Errorf("Expected no error, but got: %v", err)
				}
				if acc.Address != tc.address {
					t.Errorf("Expected address to be '%s', but got '%s'", tc.address, acc.Address)
				}
			}
		})
	}
}

func TestUpdateAccount(t *testing.T) {
	testCases := []struct {
		name           string
		accountAddress string
		mockResponse   string
		mockStatusCode int
		expectSuccess  bool
		expectError    bool
		expectedNonce  int
	}{
		{
			name:           "Successful Update",
			accountAddress: "0x123",
			mockResponse:   `{"Result":200,"Response":{"Nonce":100}}`,
			mockStatusCode: http.StatusOK,
			expectSuccess:  true,
			expectError:    false,
			expectedNonce:  101,
		},
		{
			name:           "Account Not Open",
			accountAddress: "",
			mockResponse:   "",
			mockStatusCode: http.StatusOK,
			expectSuccess:  false,
			expectError:    true,
			expectedNonce:  0, // Nonce should not change from initial 0
		},
		{
			name:           "HTTP Error - Bad Status",
			accountAddress: "0x123",
			mockResponse:   "Internal Server Error",
			mockStatusCode: http.StatusInternalServerError,
			expectSuccess:  false,
			expectError:    true,
			expectedNonce:  0,
		},
		{
			name:           "Invalid JSON Response",
			accountAddress: "0x123",
			mockResponse:   `{"Result":200,"Response":{"Nonce":"invalid"}}`, // Nonce is not an int
			mockStatusCode: http.StatusOK,
			expectSuccess:  false,
			expectError:    true,
			expectedNonce:  0,
		},
		{
			name:           "Server Response Result Not 200",
			accountAddress: "0x123",
			mockResponse:   `{"Result":400,"Response":{"Nonce":100}}`,
			mockStatusCode: http.StatusOK,
			expectSuccess:  false,
			expectError:    true,
			expectedNonce:  0,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Create a mock HTTP server
			server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.WriteHeader(tc.mockStatusCode)
				w.Write([]byte(tc.mockResponse))
			}))
			defer server.Close()

			acc := NewCEPAccount(DefaultChain, LibVersion)
			if tc.accountAddress != "" {
				acc.Open(tc.accountAddress)
			}

			// Override NAGURL and NetworkNode to point to the mock server
			// Note: In a real scenario, these might be configured via dependency injection
			// or environment variables for easier testing.
			acc.NAGURL = server.URL + "/NAG.php?cep=" // Adjust to match the expected URL structure
			acc.NetworkNode = "mock_node"             // This part of the URL is appended by UpdateAccount

			success, err := acc.UpdateAccount()

			if tc.expectError {
				if err == nil {
					t.Errorf("Expected an error but got nil")
				}
			} else {
				if err != nil {
					t.Errorf("Expected no error, but got: %v", err)
				}
			}

			if success != tc.expectSuccess {
				t.Errorf("Expected success to be %v, but got %v", tc.expectSuccess, success)
			}

			if acc.Nonce != tc.expectedNonce {
				t.Errorf("Expected Nonce to be %d, but got %d", tc.expectedNonce, acc.Nonce)
			}
		})
	}
}

func TestSetNetwork(t *testing.T) {
	// Define a default NAG URL to check if it gets updated correctly.
	const initialNagURL = "https://default.nag.url"

	testCases := []struct {
		name              string
		network           string
		mockResponse      string
		mockStatusCode    int
		initialNetworkURL string // Base URL for fetching network info
		expectError       bool
		expectedErrorMsg  string
		expectedNagURL    string
	}{
		{
			name:              "Successful Network Set",
			network:           "mainnet",
			mockResponse:      `{"status":"success", "url":"https://new.nag.url/"}`,
			mockStatusCode:    http.StatusOK,
			initialNetworkURL: "", // Will be replaced by mock server URL
			expectError:       false,
			expectedNagURL:    "https://new.nag.url/",
		},
		{
			name:              "Failed Network Set - API Error",
			network:           "invalidnet",
			mockResponse:      `{"status":"error", "message":"Invalid network specified"}`,
			mockStatusCode:    http.StatusOK,
			initialNetworkURL: "",
			expectError:       true,
			expectedErrorMsg:  "failed to set network: Invalid network specified",
			expectedNagURL:    initialNagURL, // Should not change
		},
		{
			name:              "Failed Network Set - HTTP Error",
			network:           "mainnet",
			mockResponse:      "Internal Server Error",
			mockStatusCode:    http.StatusInternalServerError,
			initialNetworkURL: "",
			expectError:       true,
			expectedErrorMsg:  "network request failed with status: 500 Internal Server Error",
			expectedNagURL:    initialNagURL, // Should not change
		},
		{
			name:              "Failed Network Set - Invalid JSON",
			network:           "mainnet",
			mockResponse:      `{"status":"success", "url":}`,
			mockStatusCode:    http.StatusOK,
			initialNetworkURL: "",
			expectError:       true,
			expectedErrorMsg:  "failed to decode network response", // Check for substring
			expectedNagURL:    initialNagURL,
		},
		{
			name:              "Failed Network Set - Invalid Base URL",
			network:           "mainnet",
			mockResponse:      "",
			mockStatusCode:    0,
			initialNetworkURL: "://invalid-url", // Malformed URL to trigger a parsing error
			expectError:       true,
			expectedErrorMsg:  "invalid network URL", // Check for substring
			expectedNagURL:    initialNagURL,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Create a mock server for tests that need it.
			var server *httptest.Server
			if tc.mockStatusCode > 0 {
				server = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
					w.WriteHeader(tc.mockStatusCode)
					w.Write([]byte(tc.mockResponse))
				}))
				defer server.Close()
			}

			acc := NewCEPAccount(DefaultChain, LibVersion)
			acc.NAGURL = initialNagURL // Set initial NAG URL

			// Set the NetworkURL for the account.
			if tc.initialNetworkURL == "" && server != nil {
				// If no specific initialNetworkURL is provided, use the mock server's URL.
				acc.NetworkURL = server.URL + "/"
			} else {
				acc.NetworkURL = tc.initialNetworkURL
			}

			err := acc.SetNetwork(tc.network)

			if tc.expectError {
				if err == nil {
					t.Fatal("Expected an error but got nil")
				}
				if !strings.Contains(err.Error(), tc.expectedErrorMsg) {
					t.Errorf("Expected error message to contain '%s', but got '%s'", tc.expectedErrorMsg, err.Error())
				}
			} else {
				if err != nil {
					t.Fatalf("Expected no error, but got: %v", err)
				}
			}

			if acc.NAGURL != tc.expectedNagURL {
				t.Errorf("Expected NAGURL to be '%s', but got '%s'", tc.expectedNagURL, acc.NAGURL)
			}
		})
	}
}

func TestSignData(t *testing.T) {
	// Generate a new private key for testing
	privateKey, err := secp256k1.GeneratePrivateKey()
	if err != nil {
		t.Fatalf("Failed to generate private key: %v", err)
	}
	privateKeyHex := hex.EncodeToString(privateKey.Serialize())

	testCases := []struct {
		name          string
		dataToSign    []byte
		privateKeyHex string
		expectError   bool
	}{
		{
			name:          "Successful Signing",
			dataToSign:    []byte("test data to be signed"),
			privateKeyHex: privateKeyHex,
			expectError:   false,
		},
		{
			name:          "Invalid Private Key Hex",
			dataToSign:    []byte("some data"),
			privateKeyHex: "invalidhex",
			expectError:   true,
		},
		{
			name:          "Empty Data",
			dataToSign:    []byte(""),
			privateKeyHex: privateKeyHex,
			expectError:   false, // Signing empty data should still work
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			acc := NewCEPAccount(DefaultChain, LibVersion)

			signature, err := acc.SignData(tc.dataToSign, tc.privateKeyHex)

			if tc.expectError {
				if err == nil {
					t.Errorf("Expected an error but got nil")
				}
				if signature != "" {
					t.Errorf("Expected empty signature but got: %s", signature)
				}
			} else {
				if err != nil {
					t.Errorf("Expected no error, but got: %v", err)
				}
				if signature == "" {
					t.Errorf("Expected a non-empty signature but got empty")
				}
			}
		})
	}
}

func TestSignDataRFC6979(t *testing.T) {
	// Generate a new private key for testing.
	privateKey, err := secp256k1.GeneratePrivateKey()
	if err != nil {
		t.Fatalf("Failed to generate private key: %v", err)
	}
	privateKeyHex := hex.EncodeToString(privateKey.Serialize())

	acc := NewCEPAccount(DefaultNAG, DefaultChain, LibVersion)

	data := []byte("test message for RFC 6979")

	// Sign the same data twice.
	sig1, err1 := acc.SignData(data, privateKeyHex)
	if err1 != nil {
		t.Fatalf("First signature generation failed: %v", err1)
	}

	sig2, err2 := acc.SignData(data, privateKeyHex)
	if err2 != nil {
		t.Fatalf("Second signature generation failed: %v", err2)
	}

	// According to RFC 6979, signatures must be deterministic.
	if sig1 != sig2 {
		t.Errorf(`Signatures are not deterministic. RFC 6979 requires that signing the same data with the same key produces the same signature.
Sig1: %s
Sig2: %s`, sig1, sig2)
	}
}

func TestClose(t *testing.T) {
	acc := NewCEPAccount(DefaultNAG, DefaultChain, LibVersion)

	// Populate fields with dummy values
	
	acc.PublicKey = "testPublicKey"
	acc.Address = "testAddress"

	// Call the Close method
	acc.Close()

	// Assert that fields are cleared
	if acc.PublicKey != "" {
		t.Errorf("Expected PublicKey to be empty, but got %s", acc.PublicKey)
	}
	if acc.Address != "" {
		t.Errorf("Expected Address to be empty, but got %s", acc.Address)
	}
}


func TestSubmitCertificate(t *testing.T) {
	// Generate a new private key for testing
	privateKey, err := secp256k1.GeneratePrivateKey()
	if err != nil {
		t.Fatalf("Failed to generate private key: %v", err)
	}
	privateKeyHex := hex.EncodeToString(privateKey.Serialize())

	testCases := []struct {
		name             string
		pdata            string
		privateKey       string
		mockResponse     string
		mockStatusCode   int
		nagURL           string
		expectError      bool
		expectedErrorMsg string
		expectedResult   map[string]interface{}
	}{
		{
			name:            "Successful Submission",
			pdata:           "test data",
			privateKey:      privateKeyHex,
			mockResponse:    `{"Result":200, "TxID":"0x123"}`,
			mockStatusCode:  http.StatusOK,
			nagURL:          "http://localhost:8080",
			expectError:     false,
			expectedResult:  map[string]interface{}{"Result": float64(200), "TxID": "0x123"},
		},
		{
			name:             "NAGURL Not Set",
			pdata:            "test data",
			privateKey:       privateKeyHex,
			mockResponse:     "",
			mockStatusCode:   0,
			nagURL:           "",
			expectError:      true,
			expectedErrorMsg: "network is not set. Please call SetNetwork() first",
		},
		{
			name:             "Invalid Private Key",
			pdata:            "test data",
			privateKey:       "invalid",
			mockResponse:     "",
			mockStatusCode:   0,
			nagURL:           "http://localhost:8080",
			expectError:      true,
			expectedErrorMsg: "failed to sign data: invalid private key hex string",
		},
		{
			name:             "HTTP Error - Non-200 Status",
			pdata:            "test data",
			privateKey:       privateKeyHex,
			mockResponse:     "Internal Server Error",
			mockStatusCode:   http.StatusInternalServerError,
			nagURL:           "http://localhost:8080",
			expectError:      true,
			expectedErrorMsg: "network returned an error",
		},
		{
			name:             "Invalid JSON Response",
			pdata:            "test data",
			privateKey:       privateKeyHex,
			mockResponse:     `invalid json`,
			mockStatusCode:   http.StatusOK,
			nagURL:           "http://localhost:8080",
			expectError:      true,
			expectedErrorMsg: "failed to decode response JSON",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			var server *httptest.Server
			if tc.nagURL != "" {
				server = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
					w.WriteHeader(tc.mockStatusCode)
					w.Write([]byte(tc.mockResponse))
				}))
				defer server.Close()
			}

			acc := NewCEPAccount(DefaultChain, LibVersion)
			if tc.nagURL != "" {
				acc.NAGURL = server.URL
			} else {
				acc.NAGURL = ""
			}

			result, err := acc.SubmitCertificate(tc.pdata, tc.privateKey)

			if tc.expectError {
				if err == nil {
					t.Fatal("Expected an error but got nil")
				}
				if !strings.Contains(err.Error(), tc.expectedErrorMsg) {
					t.Errorf("Expected error message to contain '%s', but got '%s'", tc.expectedErrorMsg, err.Error())
				}
			} else {
				if err != nil {
					t.Fatalf("Expected no error, but got: %v", err)
				}
				if len(result) != len(tc.expectedResult) {
					t.Errorf("Expected result map length %d, but got %d", len(tc.expectedResult), len(result))
				}
				for k, v := range tc.expectedResult {
					if result[k] != v {
						t.Errorf("Expected result[%s] to be %v, but got %v", k, v, result[k])
					}
				}
			}
		})
	}
}

func TestGetTransactionByID(t *testing.T) {
	testCases := []struct {
		name             string
		transactionID    string
		startBlock       string
		endBlock         string
		mockResponse     string
		mockStatusCode   int
		nagURL           string
		expectError      bool
		expectedErrorMsg string
		expectedResult   map[string]interface{}
	}{
		{
			name:           "Successful GetTransactionByID",
			transactionID:  "0xabcdef123456",
			startBlock:     "",
			endBlock:       "",
			mockResponse:   `{"status":"success", "details":"transaction details by ID"}`,
			mockStatusCode: http.StatusOK,
			nagURL:         "http://localhost:8080",
			expectError:    false,
			expectedResult: map[string]interface{}{"status": "success", "details": "transaction details by ID"},
		},
		{
			name:           "Successful GetTransactionByID with Blocks",
			transactionID:  "0xabcdef123456",
			startBlock:     "100",
			endBlock:       "200",
			mockResponse:   `{"status":"success", "details":"transaction details by ID and blocks"}`,
			mockStatusCode: http.StatusOK,
			nagURL:         "http://localhost:8080",
			expectError:    false,
			expectedResult: map[string]interface{}{"status": "success", "details": "transaction details by ID and blocks"},
		},
		{
			name:             "NAGURL Not Set",
			transactionID:    "0xabcdef123456",
			startBlock:       "",
			endBlock:         "",
			mockResponse:     "",
			mockStatusCode:   0,
			nagURL:           "",
			expectError:      true,
			expectedErrorMsg: "network is not set. Please call SetNetwork() first",
		},
		{
			name:             "HTTP Error - Non-200 Status",
			transactionID:    "0xabcdef123456",
			startBlock:       "",
			endBlock:         "",
			mockResponse:     "Not Found",
			mockStatusCode:   http.StatusNotFound,
			nagURL:           "http://localhost:8080",
			expectError:      true,
			expectedErrorMsg: "network request failed with status: 404 Not Found",
		},
		{
			name:             "Invalid JSON Response",
			transactionID:    "0xabcdef123456",
			startBlock:       "",
			endBlock:         "",
			mockResponse:     `{"status":"success", "details":}`, // Malformed JSON
			mockStatusCode:   http.StatusOK,
			nagURL:           "http://localhost:8080",
			expectError:      true,
			expectedErrorMsg: "failed to decode transaction JSON",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			var server *httptest.Server
			if tc.nagURL != "" {
				server = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
					w.WriteHeader(tc.mockStatusCode)
					w.Write([]byte(tc.mockResponse))
				}))
				defer server.Close()
			}

			acc := NewCEPAccount(DefaultChain, LibVersion)
			if tc.nagURL != "" {
				acc.NAGURL = server.URL
			} else {
				acc.NAGURL = ""
			}

			result, err := acc.GetTransactionByID(tc.transactionID, tc.startBlock, tc.endBlock)

			if tc.expectError {
				if err == nil {
					t.Fatal("Expected an error but got nil")
				}
				if !strings.Contains(err.Error(), tc.expectedErrorMsg) {
					t.Errorf("Expected error message to contain '%s', but got '%s'", tc.expectedErrorMsg, err.Error())
				}
			} else {
				if err != nil {
					t.Fatalf("Expected no error, but got: %v", err)
				}
				if len(result) != len(tc.expectedResult) {
					t.Errorf("Expected result map length %d, but got %d", len(tc.expectedResult), len(result))
				}
				for k, v := range tc.expectedResult {
					if result[k] != v {
						t.Errorf("Expected result[%s] to be %v, but got %v", k, v, result[k])
					}
				}
			}
		})
	}
}


func TestGetTransactionOutcome(t *testing.T) {
	testCases := []struct {
		name             string
		TxID             string
		timeoutSec       int
		mockResponses    []string
		mockStatusCodes  []int
		nagURL           string
		expectError      bool
		expectedErrorMsg string
		expectedOutcome  map[string]interface{}
	}{
		{
			name:            "Successful Outcome - Not Pending",
			TxID:            "0x123",
			timeoutSec:      5,
			mockResponses:   []string{`{"Result":200, "Response":{"Status":"Pending"}}`, `{"Result":200, "Response":{"Status":"Confirmed", "Value":100}}`},
			mockStatusCodes: []int{http.StatusOK, http.StatusOK},
			nagURL:          "http://localhost:8080",
			expectError:     false,
			expectedOutcome: map[string]interface{}{"Status": "Confirmed", "Value": float64(100)},
		},
		{
			name:             "Timeout Exceeded",
			TxID:             "0x456",
			timeoutSec:       1,
			mockResponses:    []string{`{"Result":200, "Response":{"Status":"Pending"}}`, `{"Result":200, "Response":{"Status":"Pending"}}`},
			mockStatusCodes:  []int{http.StatusOK, http.StatusOK},
			nagURL:           "http://localhost:8080",
			expectError:      true,
			expectedErrorMsg: "timeout exceeded",
		},
		{
			name:             "NAGURL Not Set",
			TxID:             "0x789",
			timeoutSec:       1, // Short timeout since it should fail immediately
			mockResponses:    []string{},
			mockStatusCodes:  []int{},
			nagURL:           "",
			expectError:      true,
			expectedErrorMsg: "network is not set. Please call SetNetwork() first",
		},
		{
			name:             "HTTP Error During Polling",
			TxID:             "0xabc",
			timeoutSec:       5,
			mockResponses:    []string{`Internal Server Error`},
			mockStatusCodes:  []int{http.StatusInternalServerError},
			nagURL:           "http://localhost:8080",
			expectError:      true,
			expectedErrorMsg: "timeout exceeded", // Will eventually timeout if errors persist
		},
		{
			name:             "Invalid JSON Response During Polling",
			TxID:             "0xdef",
			timeoutSec:       5,
			mockResponses:    []string{`{"Result":200, "Response":{"Status":"Pending"}}`, `invalid json`},
			mockStatusCodes:  []int{http.StatusOK, http.StatusOK},
			nagURL:           "http://localhost:8080",
			expectError:      true,
			expectedErrorMsg: "timeout exceeded", // Will eventually timeout if errors persist
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			requestCount := 0
			var server *httptest.Server
			if tc.nagURL != "" {
				server = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
					if requestCount < len(tc.mockResponses) {
						w.WriteHeader(tc.mockStatusCodes[requestCount])
						w.Write([]byte(tc.mockResponses[requestCount]))
						requestCount++
					} else {
						w.WriteHeader(http.StatusOK)
						w.Write([]byte(`{"Result":200, "Response":{"Status":"Pending"}}`)) // Default to pending if no more mock responses
					}
				}))
				defer server.Close()
			}

			acc := NewCEPAccount(DefaultChain, LibVersion)
			acc.IntervalSec = 1 // Set a short interval for faster test execution
			if tc.nagURL != "" {
				acc.NAGURL = server.URL
			} else {
				acc.NAGURL = ""
			}

			outcome, err := acc.GetTransactionOutcome(tc.TxID, tc.timeoutSec)

			if tc.expectError {
				if err == nil {
					t.Fatal("Expected an error but got nil")
				}
				if !strings.Contains(err.Error(), tc.expectedErrorMsg) {
					t.Errorf("Expected error message to contain '%s', but got '%s'", tc.expectedErrorMsg, err.Error())
				}
			} else {
				if err != nil {
					t.Fatalf("Expected no error, but got: %v", err)
				}
				if len(outcome) != len(tc.expectedOutcome) {
					t.Errorf("Expected outcome map length %d, but got %d", len(tc.expectedOutcome), len(outcome))
				}
				for k, v := range tc.expectedOutcome {
					if outcome[k] != v {
						t.Errorf("Expected outcome[%s] to be %v, but got %v", k, v, outcome[k])
					}
				}
			}
		})
	}
}
</file>

<file path=".gitignore">
.cursor
.direnv
.windsurf
result
.envrc
.env*
target
flake.*
.aider*
*.java
*.js
.env.e2e
</file>

<file path="RFC-6979.md">
A Comprehensive Guide to Implementing RFC 6979 for Deterministic ECDSA Signatures in GoThe Criticality of the Nonce in ECDSA: A Secret Under ThreatTo fully appreciate the solution presented by RFC 6979, one must first understand the problem it so effectively solves. The Elliptic Curve Digital Signature Algorithm (ECDSA) is a cornerstone of modern cryptography, used in everything from TLS web security to blockchain transactions.1 At its heart lies a per-signature secret number, the nonce, whose proper handling is paramount to the security of the entire system.The Role of 'k': ECDSA's Ephemeral SecretIn the standard ECDSA signing process, a signer (Alice) with a private key d and a corresponding public key Q=dG (where G is a known base point on the elliptic curve) signs a message m through a series of steps.3A cryptographically secure random integer k, known as the nonce, is generated for this signature only. It must be kept secret.A point on the elliptic curve is calculated by multiplying the base point by the nonce: R=kG. The x-coordinate of this point, r, becomes the first component of the signature.The message m is cryptographically hashed, resulting in a value e.The second component of the signature, s, is calculated using the private key d, the message hash e, the value r, and the inverse of the nonce k:s=k1(e+dr)(modn)where n is the order of the curve's base point.The final signature is the pair (r,s). The nonce k is ephemeral; it is generated, used once, and should be discarded. However, for that single signature's lifecycle, the secrecy of k is as critical as the long-term secrecy of the private key d.This relationship can be better understood by reframing the nonce's role. If we rearrange the signature equation, we get sk=e+dr, which can be expressed as dr=ske. In this form, it becomes clear that the term sk acts as a cryptographic mask. Since s, r, and e are public, the private key d is protected only by the secrecy and unpredictability of k. The nonce functions as a one-time symmetric key or a one-time pad for the signature, encrypting the relationship between the private key and the message. If this ephemeral key is compromised, the entire system fails.The Perils of Flawed Nonce GenerationThe history of applied cryptography is littered with examples of catastrophic failures stemming from improper nonce generation. Any deviation from a perfectly random, secret, and unique nonce can lead to the complete recovery of the signer's private key.Nonce Reuse: The Classic AttackThe most well-known vulnerability is nonce reuse. If an attacker obtains two different messages, m1 and m2, signed with the same private key d and the same nonce k, they can recover the private key with trivial algebra.4Given two signatures, (r,s1) and (r,s2), for messages with hashes e1 and e2:s1=k1(e1+dr)(modn)s2=k1(e2+dr)(modn)The attacker can compute:s1s2=k1(e1e2)(modn)From this, they can solve for the nonce k:k=(e1e2)(s1s2)1(modn)Once k is known, the attacker can substitute it back into either of the original signature equations to solve for the private key d:d=r1(s1ke1)(modn)This is not a theoretical concern. It was precisely this vulnerability that allowed for the recovery of the code-signing private key for the Sony PlayStation 3 console, a landmark security failure in a major commercial product.3Predictable and Biased Nonces: The Subtle ThreatEven if a nonce is never reused, the system can be broken if it is predictable or statistically biased. Using a weak pseudo-random number generator (PRNG), like Math.random() in JavaScript, can produce a sequence of k values that an attacker can guess or reconstruct, leading to the same key recovery attack.4A more subtle and recent example is the high-profile PuTTY vulnerability (CVE-2024-31497). PuTTY used a custom deterministic nonce generation scheme that, due to a flawed modular reduction, produced nonces where the first 60 bits were heavily biased. This statistical flaw was sufficient to allow an attacker to recover the private key after observing a few dozen signatures.5 This case is particularly instructive because it demonstrates that even a well-intentioned attempt at deterministic generation can fail catastrophically if it deviates from a rigorously vetted standard. The core issue is that any property that distinguishes the nonce k from a truly uniform random number in the valid range can potentially be exploited.6RFC 6979: The Deterministic Nonce Generation StandardIn response to the clear and present danger of flawed nonce generation, RFC 6979, "Deterministic Usage of the Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA)," was developed and published.8 It provides a standardized method to generate the nonce k deterministically, eliminating the need for a source of high-quality randomness at the time of signing.From Randomness to Determinism: The Core PhilosophyThe fundamental principle of RFC 6979 is to derive the nonce k from the inputs that are already part of the signature process: the long-term secret (the private key d) and the message hash e.4 This approach provides several key benefits:Eliminates RNG Dependencies: It completely removes the reliance on an external, high-quality, and properly seeded cryptographically secure pseudo-random number generator (CSPRNG) during the critical signing operation.9 This eradicates the entire class of vulnerabilities associated with RNG failures, nonce reuse, and nonce bias.Maintains Compatibility: A crucial design feature is that the resulting signatures are standard ECDSA signatures. A verifier does not need to know that RFC 6979 was used; the signature can be validated using the standard ECDSA verification algorithm without any modification.11Enhances Testability: Because the signature for a given message and key is always the same, it simplifies the process of writing unit tests and debugging cryptographic implementations.6The HMAC-DRBG Mechanism UnveiledThe procedure defined in RFC 6979 is far more sophisticated than a simple hash like `hash(d || e)`. It employs a mechanism based on HMAC-based Deterministic Random Bit Generator (HMAC-DRBG) to produce a nonce that is cryptographically indistinguishable from a uniformly random value.4The algorithm, as detailed in the RFC 9, proceeds as follows:Initialization: Two state values, K and V, are initialized. K is set to a string of zero bytes, and V is set to a string of one bytes, both with a length equal to the output length of the chosen hash function (e.g., 32 bytes for SHA-256).Seeding: The state is seeded with the private key d (denoted as x in the RFC) and the message hash e (denoted as h1) through a series of HMAC operations. This securely mixes the secret key and the message data into the internal state. The specific construction is:$K = \text{HMAC}_K(V \ || \ 0x00 \ || \ \text{int2octets}(x) \ || \ \text{bits2octets}(h_1))$*   V=HMACK(V)*   $K = \text{HMAC}_K(V \ || \ 0x01 \ || \ \text{int2octets}(x) \ || \ \text{bits2octets}(h_1))$*   V=HMACK(V)3.  Generation Loop: A loop begins to generate candidate bits for the nonce. In each iteration, the state is updated (V=HMACK(V)), and the result is appended to a temporary sequence T. This continues until T contains enough bits to form a number of the same bit-length as the curve order q.4.  Rejection Sampling: The bit sequence T is converted into an integer, which becomes the candidate nonce k. This candidate is then checked to ensure it falls within the valid range [1,q1]. If k=0 or kq, it is rejected.5.  Loop on Rejection: If the candidate k is rejected, the state is updated again ($K = \text{HMAC}_K(V || 0x00)$, V=HMACK(V)), and the generation loop (Step 3) is re-executed to produce a new candidate. This process repeats until a valid k is found.This rejection sampling step is the critical feature that prevents the kind of modulo bias seen in the PuTTY vulnerability. It ensures that the final nonce k is uniformly distributed across the valid range, a property that simpler methods fail to provide.5 The complexity of this procedure is not arbitrary; it is a carefully designed defense-in-depth mechanism that codifies a "pit of success" for developers. By following this standard, an implementer is protected not only from obvious RNG failures but also from the subtle, hard-to-detect statistical flaws that can arise from custom, "good enough" solutions.Security Profile: Benefits and Inherent RisksThe primary benefit of RFC 6979 is its immunity to the entire class of attacks based on flawed randomness.1 However, by making the signature process deterministic, it introduces a different, albeit more difficult, attack vector: fault injection.If an attacker can induce a transient hardware or software fault (e.g., via voltage glitching or radiation) during the HMAC-DRBG process, they might be able to cause the same nonce k to be generated for two different messages. This would re-enable the classic key recovery attack.4 This is an advanced attack that requires physical proximity or control over the signing device's environment. This risk is being actively addressed in the cryptographic community through proposals for "hedged signatures," which mix the deterministic output with a small amount of external randomness to thwart fault attacks.13Native Implementation: Using the Go Standard Library (crypto/ecdsa)For many developers, the most direct and secure path to implementing RFC 6979 is by using the capabilities built directly into the Go standard library. The Go team has provided a simple, idiomatic way to generate deterministic signatures for the most common elliptic curves.The crypto/ecdsa Package's Built-in CapabilityThe key to this functionality lies in the crypto.Signer interface and its Sign method. The Go standard library's crypto/ecdsa package contains a powerful design choice: to generate a deterministic RFC 6979 signature, a developer calls the PrivateKey.Sign method, passing a nil value for the io.Reader that would normally supply randomness.14This contrasts with the traditional method of generating a randomized signature, which involves calling ecdsa.SignASN1 with a source of randomness like crypto/rand.Reader.15 The Go documentation notes that even this randomized method is hardened against weak RNGs by mixing the provided entropy with the private key and message hash, but the deterministic path offers absolute protection from any RNG-related failure.15This API design is an exemplar of the "pit of success" philosophy. Instead of adding a new, separate function like SignRFC6979, the Go team overloaded the behavior of the existing standard Sign method. This means any code written against the generic crypto.Signer interface can support deterministic signatures without modification. The choice is pushed to the caller, and using a nil interface value as a signal for special behavior is a common and natural pattern for Go developers, reducing API clutter and the risk of misconfiguration.Tutorial: Generating Deterministic Signatures with crypto/ecdsaThe following is a complete, runnable Go program that demonstrates the generation and verification of a deterministic ECDSA signature using the standard library.Gopackage main

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"log"
)

func main() {
	// 1. Generate a new ECDSA private key using the P-256 curve.
	// The standard library's RFC 6979 implementation supports P-224, P-256, P-384, and P-521.
	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err!= nil {
		log.Fatalf("Failed to generate private key: %v", err)
	}
	publicKey := &privateKey.PublicKey

	// 2. Prepare the message to be signed.
	// The Sign method operates on a hash of the message, not the raw message.
	message :=byte("This is a message to be signed deterministically.")
	hash := sha256.Sum256(message)

	// 3. Sign the message hash deterministically according to RFC 6979.
	// This is triggered by passing 'nil' as the io.Reader (first argument).
	// The third argument, crypto.SignerOpts, must specify the hash function used.
	// For SHA-256, we can pass crypto.SHA256.
	deterministicSignature, err := privateKey.Sign(nil, hash[:], crypto.SHA256)
	if err!= nil {
		log.Fatalf("Failed to sign message deterministically: %v", err)
	}

	fmt.Printf("Deterministic Signature (hex): %s\n", hex.EncodeToString(deterministicSignature))

	// 4. Verify the signature using the public key.
	// The standard ecdsa.VerifyASN1 function works without modification.
	isValid := ecdsa.VerifyASN1(publicKey, hash[:], deterministicSignature)
	if!isValid {
		log.Fatal("Signature verification failed!")
	}
	fmt.Println("Signature successfully verified.")

	// 5. Demonstrate determinism.
	// Signing the same message with the same key again will produce the exact same signature.
	deterministicSignature2, err := privateKey.Sign(nil, hash[:], crypto.SHA256)
	if err!= nil {
		log.Fatalf("Failed to sign message a second time: %v", err)
	}

	if hex.EncodeToString(deterministicSignature) == hex.EncodeToString(deterministicSignature2) {
		fmt.Println("Success: The second signature is identical, proving determinism.")
	} else {
		log.Fatal("Failure: The second signature was different.")
	}
}
Constraints and ConsiderationsWhen using the native implementation, developers must be aware of two key constraints:Supported Curves: The built-in RFC 6979 functionality is only available for the NIST curves defined in the crypto/elliptic package: P-224, P-256, P-384, and P-521. Attempting to use it with any other curve, such as secp256k1, will result in an error.14Hash Function Matching: The crypto.SignerOpts parameter passed to the Sign method must correctly identify the hash algorithm that was used to produce the digest. If sha256.Sum256 is used, the option must be crypto.SHA256 (or an equivalent struct).14For developers wishing to inspect the implementation, the relevant logic resides in the signRFC6979 function within the crypto/ecdsa/ecdsa.go source file.14 The correctness of this implementation is validated against the RFC's own test vectors in ecdsa_test.go.18A Survey of Third-Party Libraries for RFC 6979 in GoWhile the standard library is the ideal choice for NIST curves, many applications, particularly in the blockchain space, require curves that it does not support. This necessitates the use of third-party libraries.Beyond the Standard Library: When to Use External PackagesThe single most common reason to seek an external package for ECDSA is the need to use the secp256k1 curve. This curve is the standard for Bitcoin, Ethereum, and a vast number of other cryptocurrencies and related technologies.6 Since Go's native crypto/ecdsa package does not support deterministic signing for secp256k1, developers must turn to the rich ecosystem of community-maintained libraries. This bifurcation of the ecosystem is not a sign of fragmentation but rather a mature division of labor, where the Go team maintains general-purpose cryptographic primitives and specialized communities focus on high-performance, audited implementations for their specific needs.Library Analysis and Code TutorialsThe Specialist: github.com/decred/dcrd/dcrec/secp256k1/v4/ecdsaThis package, part of the Decred cryptocurrency project, is a highly optimized, pure-Go implementation of ECDSA tailored specifically for the secp256k1 curve. It is widely regarded as a de facto standard in the Go blockchain community. Its Sign function produces deterministic, canonical signatures compliant with RFC 6979 by default.20A code example for this library is straightforward:Gopackage main

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"log"

	"github.com/decred/dcrd/dcrec/secp256k1/v4"
	"github.com/decred/dcrd/dcrec/secp256k1/v4/ecdsa"
)

func main() {
	// 1. Generate a secp256k1 private key.
	privateKey, err := secp256k1.GeneratePrivateKey()
	if err!= nil {
		log.Fatalf("Failed to generate private key: %v", err)
	}
	publicKey := privateKey.PubKey()

	// 2. Hash the message.
	message :=byte("A message for the secp256k1 world.")
	hash := sha256.Sum256(message)

	// 3. Sign the hash. The Sign function is deterministic by default.
	signature := ecdsa.Sign(privateKey, hash[:])

	fmt.Printf("secp256k1 Signature (DER-encoded hex): %s\n", hex.EncodeToString(signature.Serialize()))

	// 4. Verify the signature.
	isValid := signature.Verify(hash[:], publicKey)
	if!isValid {
		log.Fatal("Signature verification failed!")
	}
	fmt.Println("secp256k1 signature successfully verified.")
}
The Modular Tool: github.com/kklash/rfc6979This package is a small, focused library that implements only the RFC 6979 nonce generation algorithm; it does not perform the actual ECDSA signing.21 Its purpose is to generate the nonce k, which a developer would then need to pass to a low-level signing function that allows manual specification of the nonce. While excellent for educational purposes or building custom cryptographic protocols, for standard curves like secp256k1, using an integrated library like decred/dcrd is strongly preferred to avoid the risk of integration errors.The library's API involves creating a Q struct with the curve's order and calling the Nonce method 21:Go// Example of generating a nonce 'k'
q := rfc6979.NewQ(curve.Params().N) // N is the curve order
privateKeyInt := privateKey.D
messageHash := sha256.Sum256(byte("message"))
k := q.Nonce(privateKeyInt, messageHash[:], sha256.New)
// 'k' would then be used in a low-level signing function.
Historical Libraries: apisit/rfc6979 and othersOlder libraries such as github.com/apisit/rfc6979 (published in 2014) and github.com/MixinNetwork/bitshares-go/sign/rfc6979 also exist.11 While historically important, they are not recommended for new projects. The Go cryptographic landscape has evolved significantly, and modern, actively maintained libraries that have undergone more intense scrutiny, such as decred/dcrd, are far safer choices.Comparative Analysis of Implementation OptionsThe following table provides a clear comparison to guide the selection process.Featurecrypto/ecdsa (Standard Library)decred/dcrd/dcrec/secp256k1/v4/ecdsakklash/rfc6979Primary Use CaseGeneral-purpose signing with standard NIST curves.High-performance, production-grade signing for secp256k1.Standalone, curve-agnostic RFC 6979 nonce generation.Supported CurvesP-224, P-256, P-384, P-521 only.14secp256k1 only.20Curve-agnostic; requires curve order q as input.21API AbstractionHigh-level. Signing is a single method call: priv.Sign(nil,...).14High-level. Signing is a single function call: ecdsa.Sign(priv,...).20Low-level. Generates only the nonce k: q.Nonce(...).21Maintenance StatusActively maintained by the Go core team.Actively maintained by the Decred project.Stable but less recent activity.Primary AudienceGeneral Go developers, enterprise applications.Blockchain/cryptocurrency developers.Cryptography implementers, researchers, educators.RecommendationDefault choice for all supported NIST curves.Recommended choice for all secp256k1 applications.Use only if building a custom signing framework for an unsupported curve.Production-Hardening and Final RecommendationsThe complexity of modern cryptography means that a developer's primary security responsibility has shifted from algorithm implementation to the careful selection and integration of audited, standard components. Making the right architectural choice is the most critical security decision.The Cardinal Rule: Do Not Implement Your Own CryptographyThe PuTTY vulnerability serves as the ultimate cautionary tale. The catastrophic failure was not the result of a bad RNG but of creating a custom deterministic nonce scheme that was subtly but fatally flawed. The developers were aware of RFC 6979 but chose not to adopt it, incorrectly assessing their own implementation as "close enough".5 This underscores the paramount importance of using standard, well-audited libraries. The Go team invests heavily in the security of its crypto packages, including subjecting them to external audits, and leveraging this work is a developer's most effective security measure.22A Clear Decision Framework for ImplementationTo implement RFC 6979 securely in Go, developers should follow this simple decision framework:Identify the elliptic curve required by the application.If the curve is a NIST standard (P-224, P-256, P-384, or P-521):Use the standard library's crypto/ecdsa package.Generate the signature by calling privateKey.Sign(nil, digest, opts).This is the most secure, simple, and dependency-free option.If the curve is secp256k1:Use the github.com/decred/dcrd/dcrec/secp256k1/v4/ecdsa package.Generate the signature by calling ecdsa.Sign(privateKey, hash).This is the industry-standard, audited choice for this curve in Go.If the curve is any other non-standard or exotic curve:This path enters expert territory. The first step should be to rigorously question the need for a non-standard curve.If proceeding is unavoidable, it will require combining a modular nonce generator like kklash/rfc6979 with a low-level ECDSA implementation that accepts a pre-computed nonce. This approach carries a significantly higher risk of implementation error and requires expert-level cryptographic review.Auditing, Maintenance, and VerificationWhen choosing a library, prioritize those that are actively maintained and have a history of security scrutiny.7 A library like decred/dcrd, which is central to a live cryptocurrency, is subject to intense and continuous review from a community with strong financial incentives to find flaws. Regardless of the library chosen, it is good practice to verify that its implementation passes the official RFC 6979 test vectors, a sign of correctness that both the Go standard library and reputable third-party libraries adhere to.18ConclusionGo provides excellent, secure, and accessible tools for implementing deterministic ECDSA signatures according to RFC 6979. By understanding the critical and historically perilous role of the nonce, developers can appreciate the profound security benefits of this standard. The Go standard library offers a robust, built-in solution for NIST curves that is both simple and idiomatic. For the widely used secp256k1 curve, the community has produced high-quality, specialized libraries that are considered industry standards. By following the clear decision framework outlined in this report to select the appropriate, audited library for their chosen curve, a Go developer can confidently implement deterministic signatures that are resilient to the most common and dangerous classes of ECDSA attacks.
</file>

<file path="pkg/account.go">
package circular_enterprise_apis

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/lessuselesss/CEP-Go-APIs/internal/utils"
	"github.com/decred/dcrd/dcrec/secp256k1/v4"
	decdsa "github.com/decred/dcrd/dcrec/secp256k1/v4/ecdsa"
)

// CEPAccount holds the data for a Circular Enterprise Protocol account.
type CEPAccount struct {
	Address     string
	PublicKey   string
	Info        interface{}
	CodeVersion string
	LastError   string
	NAGURL      string
	NetworkNode string
	Blockchain  string
	LatestTxID  string
	Nonce       int
	Data        map[string]interface{}
	IntervalSec int
	NetworkURL  string
}

// NewCEPAccount is a factory function that creates and initializes a new CEPAccount.
func NewCEPAccount(chain, version string) *CEPAccount {
	return &CEPAccount{
		CodeVersion: LibVersion,
		NetworkURL:  NetworkURL,
		NAGURL:      "",
		Blockchain:  DefaultChain,
		Nonce:       0,
		Data:        make(map[string]interface{}),
		IntervalSec: 2,
	}
}

// Open sets the account address. This is a prerequisite for many other
// account operations. It takes the account address as a string and
// returns an error if the address is invalid.
func (a *CEPAccount) Open(address string) error {
	if address == "" {
		return errors.New("Invalid address format")
	}
	a.Address = address
	return nil
}

// UpdateAccount fetches the latest account information from the blockchain
// via the NAG (Network Access Gateway). It updates the account's public key,
// nonce, and other network-related details.
func (a *CEPAccount) UpdateAccount() (bool, error) {
	if a.Address == "" {
		return false, errors.New("Account is not open")
	}

	// Prepare the request payload
	requestData := struct {
		Blockchain string `json:"Blockchain"`
		Address    string `json:"Address"`
		Version    string `json:"Version"`
	}{
		Blockchain: a.Blockchain,
		Address:    a.Address,
		Version:    a.CodeVersion,
	}

	jsonData, err := json.Marshal(requestData)
	if err != nil {
		return false, fmt.Errorf("failed to marshal request data: %w", err)
	}

	// Construct the full URL for the API endpoint
	url := fmt.Sprintf("%s/Circular_GetWalletNonce_%s", a.NAGURL, a.NetworkNode)

	// Make the HTTP POST request
	resp, err := http.Post(url, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return false, fmt.Errorf("http post request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return false, fmt.Errorf("network request failed with status: %s", resp.Status)
	}

	// Read the entire body of the HTTP response.
	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return false, fmt.Errorf("failed to read response body: %w", err)
	}

	// Unmarshal the JSON response into a map
	var responseMap map[string]interface{}
	if err := json.Unmarshal(bodyBytes, &responseMap); err != nil {
		return false, fmt.Errorf("failed to decode response body: %w", err)
	}

	// Check for a successful result
	if result, ok := responseMap["Result"].(float64); ok && result == 200 {
		if response, ok := responseMap["Response"].(map[string]interface{}); ok {
			if nonce, ok := response["Nonce"].(float64); ok {
				a.Nonce = int(nonce) + 1
				return true, nil
			}
		}
		return false, errors.New("failed to parse nonce from response")
	} else if errMsg, ok := responseMap["Response"].(string); ok {
		return false, fmt.Errorf("server returned error: %s", errMsg)
	}

	return false, errors.New("failed to update account, invalid response from server")
}

// SetNetwork configures the account to use a specific blockchain network.
// It fetches the correct Network Access Gateway (NAG) URL for the given
// network identifier (e.g., "devnet", "testnet", "mainnet") and updates the
// NAG_URL field on the CEPAccount struct. A custom network URL can also be used.
func (a *CEPAccount) SetNetwork(network string) error {
	a.NetworkNode = network // Set the network node

	nagURL, err := GetNAG(network)
	if err != nil {
		return fmt.Errorf("failed to get NAG URL for network %s: %w", network, err)
	}
	a.NAGURL = nagURL

	return nil
}

// Close securely clears all sensitive credential data from the CEPAccount instance.
// It zeroes out the private key, public key, address, and permissions fields.
// It is a best practice to call this method when the account object is no longer
// needed to prevent sensitive data from lingering in the application's memory.
func (a *CEPAccount) Close() {
	// Setting the fields to their zero value effectively clears them.
	a.PublicKey = ""
	a.Address = ""
}

// SignData creates a cryptographic signature for the given data using the
// provided private key. It operates by first hashing the input data with
// SHA-256 and then signing the resulting hash using ECDSA with the secp256k1 curve.
//
// The dataToSign parameter is the raw data to be signed.
// The privateKeyHex parameter is the hex-encoded private key string.
//
// It returns the signature as a hex-encoded string in ASN.1 DER format.
// An error is returned if the private key is invalid or if the
// signing process fails.
func (a *CEPAccount) SignData(dataToSign []byte, privateKeyHex string) (string, error) {
	// Decode the hex-encoded private key string into a byte slice.
	privateKeyBytes, err := hex.DecodeString(utils.HexFix(privateKeyHex))
	if err != nil {
		return "", fmt.Errorf("invalid private key hex string: %w", err)
	}

	// Parse the private key bytes into a secp256k1.PrivateKey object.
	privateKey := secp256k1.PrivKeyFromBytes(privateKeyBytes)
	if privateKey == nil {
		return "", fmt.Errorf("failed to parse private key from bytes")
	}

	// Hash the input data using SHA-256. The signing algorithm operates on a
	// fixed-size hash of the data, not the raw data itself.
	hasher := sha256.New()
	hasher.Write(dataToSign)
	hashedData := hasher.Sum(nil)

	// Sign the hashed data with the private key using the secp256k1 library.
	// The Sign function from decred/dcrd/dcrec/secp256k1/v4/ecdsa is deterministic by default.
	signature := decdsa.Sign(privateKey, hashedData)

	// The signature is returned as a raw byte slice. We need to serialize it to DER format
	// for compatibility, as the original function returned ASN.1 DER.
	return hex.EncodeToString(signature.Serialize()), nil
}



// GetTransactionByID retrieves the details of a specific transaction from the blockchain
// using its unique transaction ID, and optionally a start and end block.
//
// The transactionID parameter is the unique string identifying the transaction.
// The startBlock and endBlock parameters are optional and can be empty strings.
//
// On success, it returns a map[string]interface{} containing the transaction
// details. An error is returned if the NAG_URL is not set, the network request
// fails, or the response body cannot be properly parsed.
func (a *CEPAccount) GetTransactionByID(transactionID, startBlock, endBlock string) (map[string]interface{}, error) {
	// A Network Access Gateway URL must be configured to identify the target network.
	if a.NAGURL == "" {
		return nil, fmt.Errorf("network is not set. Please call SetNetwork() first")
	}

	// Prepare the request payload
	requestData := struct {
		TxID  string `json:"TxID"`
		Start string `json:"Start"`
		End   string `json:"End"`
	}{
		TxID:  transactionID,
		Start: startBlock,
		End:   endBlock,
	}

	jsonData, err := json.Marshal(requestData)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request data: %w", err)
	}

	// Construct the full URL for the API endpoint
	requestURL := fmt.Sprintf("%s/Circular_GetTransactionbyID_%s", a.NAGURL, a.NetworkNode)

	// Make the HTTP POST request
	resp, err := http.Post(requestURL, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("http post request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("network request failed with status: %s", resp.Status)
	}

	// Read the entire body of the HTTP response.
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Unmarshal the JSON response into a map. This provides a flexible structure
	// for accessing transaction data, which can have a variable schema.
	var transactionDetails map[string]interface{}
	if err := json.Unmarshal(body, &transactionDetails); err != nil {
		return nil, fmt.Errorf("failed to decode transaction JSON: %w", err)
	}

	return transactionDetails, nil
}

// SubmitCertificate sends a given certificate to the blockchain for processing
// and inclusion. It serializes the certificate object into a JSON payload and
// submits it to the account's configured Network Access Gateway (NAG) URL.
//
// The 'pdata' parameter is the raw data to be included in the certificate.
// The 'privateKey' parameter is the private key used for signing.
//
// On success, it returns a map[string]interface{} containing the response from
// the network, which typically includes a transaction hash. An error is returned
// if the NAG_URL is not set, if the certificate cannot be serialized, or if the
// network request fails.
func (a *CEPAccount) SubmitCertificate(pdata string, privateKey string) (map[string]interface{}, error) {
	// A Network Access Gateway URL must be configured to identify the target network.
	if a.NAGURL == "" {
		return nil, fmt.Errorf("network is not set. Please call SetNetwork() first")
	}

	// Create the PayloadObject
	payloadObject := map[string]interface{}{
		"data": pdata,
	}

	// Marshal PayloadObject to JSON string
	payloadObjectBytes, err := json.Marshal(payloadObject)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal payload object: %w", err)
	}
	payload := hex.EncodeToString(payloadObjectBytes)

	// Generate Timestamp
	timestamp := utils.GetFormattedTimestamp()

	// Construct the string for hashing
	str := fmt.Sprintf("%s%s%s%s", a.Address, a.NetworkNode, payload, timestamp)

	// Generate ID using SHA-256
	hasher := sha256.New()
	hasher.Write([]byte(str))
	id := hex.EncodeToString(hasher.Sum(nil))

	// Call SignData to get the Signature
	signature, err := a.SignData([]byte(str), privateKey)
	if err != nil {
		return nil, fmt.Errorf("failed to sign data: %w", err)
	}

	// Construct the final data payload for the HTTP request
	requestData := map[string]interface{}{
		"ID":         id,
		"From":       utils.HexFix(a.Address),
		"To":         utils.HexFix(a.Address),
		"Timestamp":  timestamp,
		"Payload":    payload,
		"Nonce":      fmt.Sprintf("%d", a.Nonce),
		"Signature":  signature,
		"Blockchain": a.Blockchain,
		"Type":       "C_TYPE_CERTIFICATE",
		"Version":    a.CodeVersion,
	}

	jsonData, err := json.Marshal(requestData)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request data: %w", err)
	}

	// Construct the full URL for the API endpoint
	requestURL := fmt.Sprintf("%s/Circular_AddTransaction_%s", a.NAGURL, a.NetworkNode)

	// Create a new HTTP POST request. The body of the request is the JSON payload.
	req, err := http.NewRequest("POST", requestURL, bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	// Execute the HTTP request using a default client.
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to submit certificate: %w", err)
	}
	defer resp.Body.Close()

	// Read the response from the network.
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for non-successful HTTP status codes.
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("network returned an error - status: %s, body: %s", resp.Status, string(body))
	}

	// Unmarshal the JSON response into a map for flexible access to the result.
	var responseMap map[string]interface{}
	if err := json.Unmarshal(body, &responseMap); err != nil {
		return nil, fmt.Errorf("failed to decode response JSON: %w", err)
	}

	
	return responseMap, nil
}

// GetTransactionOutcome retrieves the final processing result of a transaction
// from the blockchain using its unique ID. This is often used to confirm
// whether a submitted transaction was successfully validated and included in a block.
//
// The 'transactionID' parameter is the unique string identifying the transaction.
//
// It returns a map[string]interface{} containing the outcome details on success.
// An error is returned if the NAG_URL is not configured, the network request fails,
// or the JSON response cannot be parsed.
func (a *CEPAccount) GetTransactionOutcome(TxID string, timeoutSec int) (map[string]interface{}, error) {
	if a.NAGURL == "" {
		return nil, fmt.Errorf("network is not set. Please call SetNetwork() first")
	}
	startTime := time.Now()
	timeout := time.Duration(timeoutSec) * time.Second

	for {
		elapsedTime := time.Since(startTime)
		if elapsedTime > timeout {
			return nil, fmt.Errorf("timeout exceeded")
		}

		data, err := a.GetTransactionByID(TxID, "", "")
		if err != nil {
			// Continue polling even if there's an error, in case it's a temporary issue
			fmt.Printf("Error fetching transaction: %v, polling again...\n", err)
		} else {
			// Check for a definitive status
			if result, ok := data["Result"].(float64); ok && result == 200 {
				if response, ok := data["Response"].(map[string]interface{}); ok {
					if status, ok := response["Status"].(string); ok && status != "Pending" {
						return response, nil // Resolve if transaction is found and not pending
					}
				}
			}
		}

		fmt.Println("Transaction not yet confirmed or not found, polling again...")
		time.Sleep(time.Duration(a.IntervalSec) * time.Second) // Continue polling
	}
}
</file>

<file path="internal/utils/utils_test.go">
package utils

import (
	"strings"
	"testing"
	"time"
)

func TestGetFormattedTimestamp(t *testing.T) {
	// Call the function to get the formatted timestamp
	timestamp := GetFormattedTimestamp()

	// Split the timestamp into date and time parts
	parts := strings.Split(timestamp, "-")
	if len(parts) != 2 {
		t.Errorf("Timestamp does not have the expected format (YYYY:MM:DD-HH:MM:SS). Received: %s", timestamp)
		return
	}

	// Validate the date part
	dateParts := strings.Split(parts[0], ":")
	if len(dateParts) != 3 {
		t.Errorf("Date part does not have the expected format (YYYY:MM:DD). Received: %s", parts[0])
		return
	}

	// Validate the time part
	timeParts := strings.Split(parts[1], ":")
	if len(timeParts) != 3 {
		t.Errorf("Time part does not have the expected format (HH:MM:SS). Received: %s", parts[1])
		return
	}

	// Ensure the timestamp represents a valid time
	parsedTime, err := time.Parse("2006:01:02-15:04:05", timestamp)
	if err != nil {
		t.Errorf("Timestamp is not valid. Error: %v", err)
		return
	}

	// Ensure the parsed time is close to the current time (within a few seconds)
	now := time.Now().UTC()
	diff := now.Sub(parsedTime)
	if diff.Seconds() > 5 || diff.Seconds() < -5 {
		t.Errorf("Timestamp is not close to the current UTC time. Difference: %v seconds", diff.Seconds())
	}
}

func TestPadNumber(t *testing.T) {
	// Test case for a single-digit number
	t.Run("single digit", func(t *testing.T) {
		result := PadNumber(5)
		expected := "05"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	// Test case for a double-digit number
	t.Run("double digit", func(t *testing.T) {
		result := PadNumber(12)
		expected := "12"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	// Test case for zero
	t.Run("zero", func(t *testing.T) {
		result := PadNumber(0)
		expected := "00"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	// Test case for the boundary condition
	t.Run("boundary ten", func(t *testing.T) {
		result := PadNumber(10)
		expected := "10"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	// TODO: Review the expected behavior for negative numbers with the originator.
	// The current implementation does not handle negative numbers in the same way as the corrected Go function.
	// Test case for a negative number
	// t.Run("negative single digit", func(t *testing.T) {
	// 	result := padNumber(-5)
	// 	expected := "-05"
	// 	if result != expected {
	// 		t.Errorf("Expected %s, but got %s", expected, result)
	// 	}
	// })
}

func TestHexFix(t *testing.T) {
	t.Run("with prefix", func(t *testing.T) {
		result := HexFix("0x123")
		expected := "123"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	t.Run("without prefix", func(t *testing.T) {
		result := HexFix("123")
		expected := "123"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	t.Run("empty string", func(t *testing.T) {
		result := HexFix("")
		expected := ""
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	t.Run("only prefix", func(t *testing.T) {
		result := HexFix("0x")
		expected := ""
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	t.Run("prefix in middle", func(t *testing.T) {
		result := HexFix("10x23")
		expected := "10x23"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})
}

func TestStringToHex(t *testing.T) {
	t.Run("ascii string", func(t *testing.T) {
		result := StringToHex("hello")
		expected := "68656c6c6f"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	t.Run("empty string", func(t *testing.T) {
		result := StringToHex("")
		expected := ""
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

	t.Run("string with numbers and symbols", func(t *testing.T) {
		result := StringToHex("123!@#")
		expected := "313233214023"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})
}

func TestHexToString(t *testing.T) {
	t.Run("valid hex string", func(t *testing.T) {
		result := HexToString("68656c6c6f")
		expected := "hello"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

		t.Run("with 0x prefix", func(t *testing.T) {
		result := HexToString("0x68656c6c6f")
		expected := "hello"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

		t.Run("empty string", func(t *testing.T) {
		result := HexToString("")
		expected := ""
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

		t.Run("invalid hex string", func(t *testing.T) {
		result := HexToString("invalid")
		expected := ""
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})

		t.Run("with null byte", func(t *testing.T) {
		result := HexToString("68656c006c6f")
		expected := "hello"
		if result != expected {
			t.Errorf("Expected %s, but got %s", expected, result)
		}
	})
}
</file>

<file path="tests/integration/circular_enterprise_apis_integration_test.go">
package integration

import (
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"

	"github.com/joho/godotenv"
	cep "github.com/lessuselesss/CEP-Go-APIs/pkg"
)

func TestMain(m *testing.M) {
	// Load .env file from the current directory (tests/integration)
	// This makes the environment variables available to the tests
	err := godotenv.Load()
	if err != nil {
		// If the .env file is not found, we don't fail the test,
		// as the tests are designed to skip if the env vars are not set.
		// We just log that it wasn't loaded.
		fmt.Println("Error loading .env file, tests requiring env vars will be skipped.")
	}
	// Run the tests
	os.Exit(m.Run())
}

func TestCircularOperations(t *testing.T) {
	privateKeyHex := os.Getenv("CIRCULAR_PRIVATE_KEY")
	address := os.Getenv("CIRCULAR_ADDRESS")
	if privateKeyHex == "" || address == "" {
		t.Skip("Skipping test: CIRCULAR_PRIVATE_KEY and CIRCULAR_ADDRESS environment variables must be set")
	}

	// Create a mock server to handle network requests
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if strings.Contains(r.URL.Path, "GetWalletNonce") {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"Result":200,"Response":{"Nonce":1}}`))
		} else if strings.Contains(r.URL.Path, "Circular_GetTransactionbyID_") {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"Result":200,"Response":{"Status":"Confirmed"}}`))
		} else if strings.Contains(r.URL.Path, "transaction") {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"Result":200,"Response":{"Status":"Confirmed"}}`))
		} else {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"txHash":"0x12345","status":"success"}`))
		}
	}))
	defer server.Close()

	acc := cep.NewCEPAccount("testnet", "1.0")

	// Decode the private key and set it on the account

	var err error
	err = acc.Open(address)
	if err != nil {
		t.Fatalf("acc.Open() failed: %v", err)
	}

	ok, err := acc.UpdateAccount()
	if !ok || err != nil {
		t.Fatalf("acc.UpdateAccount() failed: ok=%v, err=%v", ok, err)
	}

	var resp map[string]interface{}
	resp, err = acc.SubmitCertificate("test message", privateKeyHex)
	if err != nil {
		t.Fatalf("acc.SubmitCertificate() failed: %v", err)
	}

	txHash, ok := resp["txHash"].(string)
	if !ok {
		t.Fatal("txHash not found in response")
	}

	var outcome map[string]interface{}
	outcome, err = acc.GetTransactionOutcome(txHash, 10)
	if err != nil {
		t.Fatalf("acc.GetTransactionOutcome() failed: %v", err)
	}

	if status, _ := outcome["Status"].(string); status != "Confirmed" {
		t.Errorf("Expected transaction status to be 'Confirmed', but got '%s'", status)
	}

	// TODO: Implement TestCircularOperations
}

func TestCertificateOperations(t *testing.T) {
	privateKeyHex := os.Getenv("CIRCULAR_PRIVATE_KEY")
	address := os.Getenv("CIRCULAR_ADDRESS")
	if privateKeyHex == "" || address == "" {
		t.Skip("Skipping test: CIRCULAR_PRIVATE_KEY and CIRCULAR_ADDRESS environment variables must be set")
	}

	// Create a mock server to handle network requests
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if strings.Contains(r.URL.Path, "GetWalletNonce") {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"Result":200,"Response":{"Nonce":1}}`))
		} else if strings.Contains(r.URL.Path, "Circular_GetTransactionbyID_") {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"Result":200,"Response":{"Status":"Confirmed"}}`))
		} else {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"txHash":"0x12345","status":"success"}`))
		}
	}))
	defer server.Close()

	acc := cep.NewCEPAccount("testnet", "1.0")

	var err error
	err = acc.Open(address)
	if err != nil {
		t.Fatalf("acc.Open() failed: %v", err)
	}

	ok, err := acc.UpdateAccount()
	if !ok || err != nil {
		t.Fatalf("acc.UpdateAccount() failed: ok=%v, err=%v", ok, err)
	}

	resp, err := acc.SubmitCertificate("test certificate data", privateKeyHex)
	if err != nil {
		t.Fatalf("acc.SubmitCertificate() failed: %v", err)
	}

	txHash, ok := resp["txHash"].(string)
	if !ok {
		t.Fatal("txHash not found in response")
	}

	outcome, err := acc.GetTransactionOutcome(txHash, 10)
	if err != nil {
		t.Fatalf("acc.GetTransactionOutcome() failed: %v", err)
	}

	if status, _ := outcome["Status"].(string); status != "Confirmed" {
		t.Errorf("Expected transaction status to be 'Confirmed', but got '%s'", status)
	}
}

func TestHelloWorldCertification(t *testing.T) {
	privateKeyHex := os.Getenv("CIRCULAR_PRIVATE_KEY")
	address := os.Getenv("CIRCULAR_ADDRESS")
	if privateKeyHex == "" || address == "" {
		t.Skip("Skipping test: CIRCULAR_PRIVATE_KEY and CIRCULAR_ADDRESS environment variables must be set")
	}

	// Create a mock server to handle network requests
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if strings.Contains(r.URL.Path, "GetWalletNonce") {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"Result":200,"Response":{"Nonce":1}}`))
		} else if strings.Contains(r.URL.Path, "Circular_GetTransactionbyID_") {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"Result":200,"Response":{"Status":"Confirmed"}}`))
		} else {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"txHash":"0x12345","status":"success"}`))
		}
	}))
	defer server.Close()

	acc := cep.NewCEPAccount("testnet", "1.0")

	var err error
	err = acc.Open(address)
	if err != nil {
		t.Fatalf("acc.Open() failed: %v", err)
	}

	ok, err := acc.UpdateAccount()
	if !ok || err != nil {
		t.Fatalf("acc.UpdateAccount() failed: ok=%v, err=%v", ok, err)
	}

	resp, err := acc.SubmitCertificate("Hello World", privateKeyHex)
	if err != nil {
		t.Fatalf("acc.SubmitCertificate() failed: %v", err)
	}

	txHash, ok := resp["txHash"].(string)
	if !ok {
		t.Fatal("txHash not found in response")
	}

	outcome, err := acc.GetTransactionOutcome(txHash, 10)
	if err != nil {
		t.Fatalf("acc.GetTransactionOutcome() failed: %v", err)
	}

	if status, _ := outcome["Status"].(string); status != "Confirmed" {
		t.Errorf("Expected transaction status to be 'Confirmed', but got '%s'", status)
	}
}
</file>

<file path="pkg/circular_enterprise_apis_test.go">
package circular_enterprise_apis

import (
	"fmt"
	"io"
	"net/http"
	"strings"
	"testing"
)


// TestNewAccount verifies that the NewAccount method correctly initializes an Account instance
// with the parent CEP's network configuration.
func TestNewAccount(t *testing.T) {
	acc := NewCEPAccount(DefaultChain, LibVersion)

	if acc == nil {
		t.Fatal("NewAccount returned nil")
	}
	if acc.NAGURL != DefaultNAG {
		t.Errorf("Expected NAGURL to be %s, got %s", DefaultNAG, acc.NAGURL)
	}
}

// TestNewCertificate verifies that the NewCertificate method correctly initializes a Certificate instance
// with the parent CEP's network configuration.
func TestNewCertificate(t *testing.T) {
	cert := NewCertificate(LibVersion)

	if cert == nil {
		t.Fatal("NewCertificate returned nil")
	}
	if cert.Version != LibVersion {
		t.Errorf("Expected Version to be %s, got %s", LibVersion, cert.Version)
	}
}

// mockRoundTripper is a custom http.RoundTripper for mocking HTTP responses in tests.
type mockRoundTripper struct {
	response *http.Response
	err      error
}

func (m *mockRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	return m.response, m.err
}

// errorReader is an io.Reader that always returns an error.
type errorReader struct{}

func (e *errorReader) Read(p []byte) (n int, err error) {
	return 0, fmt.Errorf("i/o error")
}

// TestGetNAG tests the network discovery function.
func TestGetNAG(t *testing.T) {
	originalTransport := http.DefaultClient.Transport
	defer func() {
		http.DefaultClient.Transport = originalTransport
	}()

	t.Run("SuccessfulDiscovery", func(t *testing.T) {
		expectedNAG := "https://test-nag.circularlabs.io/"
		http.DefaultClient.Transport = &mockRoundTripper{
			response: &http.Response{
				StatusCode: http.StatusOK,
				Body:       io.NopCloser(strings.NewReader(expectedNAG)),
			},
		}

		nag, err := GetNAG("testnet")
		if err != nil {
			t.Fatalf("Expected no error, but got %v", err)
		}
		if nag != expectedNAG {
			t.Errorf("Expected NAG URL %s, but got %s", expectedNAG, nag)
		}
	})

	t.Run("FailedDiscovery", func(t *testing.T) {
		http.DefaultClient.Transport = &mockRoundTripper{
			err: fmt.Errorf("network error"),
		}

		_, err := GetNAG("testnet")
		if err == nil {
			t.Fatal("Expected an error, but got none")
		}
	})

	t.Run("Non200StatusCode", func(t *testing.T) {
		http.DefaultClient.Transport = &mockRoundTripper{
			response: &http.Response{
				StatusCode: http.StatusNotFound,
				Body:       io.NopCloser(strings.NewReader("Not Found")),
			},
		}

		body, err := GetNAG("testnet")
		if err != nil {
			t.Fatalf("Expected no error based on current implementation, but got %v", err)
		}
		if body != "Not Found" {
			t.Errorf("Expected body 'Not Found', but got '%s'", body)
		}
	})

	t.Run("BodyReadError", func(t *testing.T) {
		http.DefaultClient.Transport = &mockRoundTripper{
			response: &http.Response{
				StatusCode: http.StatusOK,
				Body:       io.NopCloser(&errorReader{}),
			},
		}

		_, err := GetNAG("testnet")
		if err == nil {
			t.Fatal("Expected an error due to body read failure, but got none")
		}
	})

	t.Run("EmptyNetworkString", func(t *testing.T) {
		expectedNAG := "https://default-nag.circularlabs.io/"
		http.DefaultClient.Transport = &mockRoundTripper{
			response: &http.Response{
				StatusCode: http.StatusOK,
				Body:       io.NopCloser(strings.NewReader(expectedNAG)),
			},
		}

		nag, err := GetNAG("")
		if err != nil {
			t.Fatalf("Expected no error for empty network string, but got %v", err)
		}
		if nag != expectedNAG {
			t.Errorf("Expected NAG URL %s, but got %s", expectedNAG, nag)
		}
	})
}




func TestCertificateOperations(t *testing.T) {
	// TODO: Implement TestCertificateOperations
}

func TestHelloWorldCertification(t *testing.T) {
	// TODO: Implement TestHelloWorldCertification
}
</file>

<file path="main.go">
package main

import (
	"log"

	"github.com/joho/godotenv"
)

func main() {
	// Load environment variables from .env file
	err := godotenv.Load()
	if err != nil {
		log.Printf("Error loading .env file: %v", err)
		// Optionally, you can exit here if .env is critical
		// os.Exit(1)
	}

	// This is the main entry point for the application.
	// The test suite targets the library packages, not this executable.

	// Example of accessing an environment variable:
	// circularAddress := os.Getenv("CIRCULAR_ADDRESS")
	// if circularAddress != "" {
	// 	log.Printf("CIRCULAR_ADDRESS: %s", circularAddress)
	// }
}
</file>

<file path="internal/utils/utils.go">
package utils

import (
	"encoding/hex"
	"fmt"
	"strings"
	"time"
)

// PadNumber adds a leading zero to numbers less than 10.
func PadNumber(num int) string {
	if num < 10 {
		return fmt.Sprintf("0%d", num)
	}
	return fmt.Sprintf("%d", num)
}

// GetFormattedTimestamp generates a UTC timestamp in YYYY:MM:DD-HH:MM:SS format.
func GetFormattedTimestamp() string {
	now := time.Now().UTC()
	year := now.Year()
	month := PadNumber(int(now.Month()))
	day := PadNumber(now.Day())
	hours := PadNumber(now.Hour())
	minutes := PadNumber(now.Minute())
	seconds := PadNumber(now.Second())
	return fmt.Sprintf("%d:%s:%s-%s:%s:%s", year, month, day, hours, minutes, seconds)
}

// HexFix removes '0x' prefix from hexadecimal strings if present.
func HexFix(word string) string {
	if strings.HasPrefix(word, "0x") {
		return word[2:]
	}
	return word
}

// StringToHex converts a string to its hexadecimal representation.
func StringToHex(str string) string {
	return hex.EncodeToString([]byte(str))
}

// HexToString converts a hexadecimal string back to its original string form.
func HexToString(hexStr string) string {
	cleanedHex := HexFix(hexStr)
	bytes, err := hex.DecodeString(cleanedHex)
	if err != nil {
		return ""
	}
	// Strip null bytes to match the reference implementation
	return strings.ReplaceAll(string(bytes), "\x00", "")
}
</file>

<file path="pkg/circular_enterprise_apis.go">
package circular_enterprise_apis

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
)

// Constants define default network parameters and library metadata.
const (
	// LibVersion specifies the current version of the library.
	LibVersion = "1.0.13"

	// NetworkURL is the base endpoint for discovering a Network Access Gateway (NAG).
	NetworkURL = "https://circularlabs.io/network/getNAG?network="

	// DefaultChain is the blockchain identifier for the default public network.
	DefaultChain = "0x8a20baa40c45dc5055aeb26197c203e576ef389d9acb171bd62da11dc5ad72b2"

	// DefaultNAG is the URL for the default public Network Access Gateway.
	DefaultNAG = "https://nag.circularlabs.io/NAG.php?cep="
)


// GetNAG is a standalone utility function for discovering the NAG URL for a
// given network identifier. It makes an HTTP request to the public NetworkURL endpoint.
func GetNAG(network string) (string, error) {
	resp, err := http.Get(NetworkURL + network)
	if err != nil {
		return "", fmt.Errorf("failed to fetch NAG URL: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read response body: %w", err)
	}

	var nagResponse struct {
		URL string `json:"url"`
	}

	if err := json.Unmarshal(body, &nagResponse); err != nil {
		return "", fmt.Errorf("failed to unmarshal NAG response: %w", err)
	}

	if nagResponse.URL == "" {
		return "", fmt.Errorf("NAG URL not found in response: %s", string(body))
	}

	return nagResponse.URL, nil
}
</file>

<file path="go.mod">
module github.com/lessuselesss/CEP-Go-APIs

go 1.24.4

require (
	github.com/circular-protocol/circular-go v0.0.0-20241027102342-f2ff57add44b
	github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0
)

require (
	github.com/btcsuite/btcd/chaincfg/chainhash v1.0.1 // indirect
	github.com/decred/dcrd/dcrec/secp256k1 v1.0.4 // indirect
	github.com/decred/dcrd/dcrec/secp256k1/v2 v2.0.0 // indirect
	github.com/joho/godotenv v1.5.1 // indirect
)
</file>

</files>
